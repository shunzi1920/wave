INTSourceChangelist:2589299
Availability:Public
Title:ポストプロセスマテリアル
Crumbs: %ROOT%, Engine, Engine/Rendering/PostProcessEffects
Description:マテリアル エディタで渡されるカスタム ポストプロセスの作成およびブレンド方法

![](Teaser3.png)
![](Teaser0.png)
![](Teaser1.png)
![](Teaser2.png)


## ポストプロセスのグラフ

[EXCERPT:PostProcessMaterials_Desc]
エンジンにはポストプロセス ノードのグラフに基づいた複雑なポストプロセスが備わっています。**ポストプロセスマテリアル** は
追加的にある特定の位置へ挿入することができます。全グラフのダンプされた内容を確認するには [FAQ](#FAQ) の **r.CompositionGraphDebug** を参照してください。
グラフはポストプロセス処理のみではなく、ライティングの一部も処理しています。いずれは、マテリアルエディタからより多くの部分を
カスタマイズできるように計画しています。
[/EXCERPT:PostProcessMaterials_Desc]

ほとんどの場合、グラフは中間レンダリング ターゲットを自動作成します。つまり元の色とブレンドしたい場合、
 (PostProcessInput0 からの入力を使って) シェーダーでブレンドする必要があります。

[EXCERPT:PostMatWarning]
[REGION:warning]
ポストプロセスのマテリアルは、本当に必要な場合に限り慎重に使用してください。カラーの補正や調整、ブルーム、被写界深度や他の様々なエフェクトなどは、可能な限り Post Process Volume 固有の設定を使用するようにしてください。この設定はすでに最適化されていてより効率的です。 
[/REGION]
[/EXCERPT:PostMatWarning]

## ポストプロセス マテリアルの使用

ポストプロセス設定 (通常はポストプロセスボリュームまたはカメラ設定で定義) で (いわゆる) ブレンドが可能なアセットをブレンドすることができます。
現時点では、 **マテリアル** と **マテリアルインスタンス** のみがブレンドが可能なアセットです。エンジンは多少のポストプロセス マテリアルを備えていますが、
プログラマーの助けを借りなくても独自の **カスタム仕様のポストプロセス** を作成することができます。

1つ以上のポストプロセスマテリアルを、 **Misc** セクションの **Blendables** へポストプロセスボリュームアクタとして割り当てます。まず「＋」キーを押して新スロットを追加し、
**コンテンツ ブラウザ** でマテリアルを選択して左矢印キーで割り当てます。ここで順序は重要ではなく、未使用のスロットは単に無視されます。

![](PostProcessSettings.gif)

##簡単なポストプロセス マテリアルの作成

ゼロからポストプロセス マテリアルのエフェクトを作成する概要については、以下をご覧ください。 [](Engine/Rendering/PostProcessEffects/PostProcessMaterials/PostProcessDemoMaterialOverview)

![](Engine/Rendering/PostProcessEffects/PostProcessMaterials/PostProcessDemoMaterialOverview/FinalPostEffect.png)(w:640)

##ポストプロセス マテリアルの重要な設定

ポストプロセスマテリアルはマテリアルドメインの **ポストプロセス** を指定しなくてはいけません：

![](DomainPostProcess.png)　　

マテリアルは新しい色の出力に *EmissiveColor* のみを使用しなくてはいけません。さらに、ポストプロセス処理中にこのパスの適用場所を定義することが可能で、
複数の場合は処理順序 (優先順位) を定義することができます。

![](PostProcessMaterialProps.png)

| ブレンド可能な位置| 説明 |
| -------- | ----------- |
| **Before Tonemapping** | PostProcessInput0は、HDRへ最大限のライティングでシーンの色を提供します。 これは一時的なアンチエイリアス処理やGBufferルックアップと一緒に問題の修正に使用します。例えば深度やノーマルなど。|
| **After Tonemapping** | 色がLDR時の優先位置で、より少ない精度と情報量を必要とします。トーンマッピングとカラーグレーディングの後に行う処理です。|
| **Before Translucency** | 透過がシーンカラーと組み合わさる前の、 'Before Tonemapping' より早い段階のパイプラインのイベントです。SeparateTranslucencyは、通常の透過より後に合成されることに注意してください。 |
| **Replacing the Tonemapper** | PostProcessInput0 は HDR シーンカラー、PostProcessInput1 は SeparateTranslucency (アルファはマスク) を提供し、 PostprocessInput2 には解像度の低いブルーム入力が付いています。 |

通常のポストプロセスの入力は、前のパスから入ってきます。**PostProcessInput0** の使用時は、 SceneTexture マテリアル式から色にアクセスできます。SceneColor を使用しても、適切な結果が得られないことがあります。

## 異なるマテリアル インスタンスのブレンド

ポストプロセス ボリュームで、複数のポストプロセス マテリアル間に滑らかな移行を簡単に設定することができます。ここでは「Unbound」にマークが付けられ、より大きなブレンド半径を持つあるボリュームを使用しています（例えば1000）。

![](BlendingAVolume.png)

各ボリュームに同一マテリアルの異なるマテリアルインスタンスを指定します。色は 2 つのマテリアル インスタンスに対して異なる設定が可能なマテリアル パラメータとして指定します。

カメラ位置に応じてボリュームの設定を使用します：

[REGION:imagetable]
| ![](VignetteG.png) | ![](VignetteR.png) |
| ------ | ------ |
| 緑のビネットマテリアルインスタンス | 赤のビネットマテリアルインスタンス |
[/REGION]


カメラの移動で、 2 つの効果設定の間にスムーズな線形変換を感じることができます。

[REGION:note]
すべてのマテリアル インスタンス プロパティは、プロパティのチェックボックスのチェック状況に関係なくブレンドされます。
全てのマテリアルインスタンスプロパティがブレンドされます。チェックボックスがチェックされていないプロパティは効果を得られないポストプロセス設定とは異なります。
つまりマテリアル インスタンスをブレンドすると、全てのプロパティがブレンドされます。
[/REGION]

## マテリアル式 "SceneTexture"

マテリアルへ**SceneTexture**マテリアル式を追加して、式プロパティで参照するテクスチャを選択します：

![](SceneTextureProps.png)

ノードには任意の入力値と複数の出力値があります： 

![](SceneTextureExpression.png)

**UV** 入力値でテクスチャルックアップを行う位置を指定することができます（Color出力値のみに使用）。
Color出力値は4チャンネル出力（実際のチャンネル割り当てはシーンテクスチャIDに依存します）です。 **サイズ** は、
テクスチャの幅と高さの2コンポーネントベクター値です。この逆数（1/幅、1/高さ）は、 **InvSize** 出力から取得します。以下の例のように、
隣接するサンプルの参照に便利です。

![](DepthNextTo.png)

マテリアル式は、現ピクセルと隣接するピクセルの深度の違いを計算します（例えばIn=0.1は下のピクセルへデルタ値を返します）。

## GBuffer プロパティの使用

GBuffer は、シェーディングの計算（ライトとマテリアルの相互処理方法）にマテリアルを格納する複数のテクスチャ（例えばサブサーフェス/スペキュラカラー、ラフネスなど）や、
ライティングを使用しないオブジェクト配列（例えばノーマル、深度）で構成されます。ディファードレンダラーは、最初に GBuffer をレンダリングしてから GBuffer 配列と一緒に
全体のライティング（ディファード）を計算します。UE4 がディファードシェーディングパスを使用する場合 (例えばDirectX 11または高性能 OpenGL)、ポストプロセス処理中にこれらのバッファへアクセスすることができます。

GBufferピクセル/テクセルは出力ピクセルと1：1で結びつかないないため、アンチエイリアス処理がアクセスを多少困難にします（下記セクション参照）。

## CustomDepth

この別の機能は、オブジェクトを別の深度バッファ（カスタム深度バッファと呼びます）でレンダリングすることによって、特定のオブジェクトをマスクします。
余分なドローコールを追加しますが、マテリアルは追加しません。深度のみを出力するため、レンダリングは比較的低コストです。この機能はメッシュでアクティベートできます。
（例えばスタティックメッシュプロパティやレンダリングのカスタム深度）：

![](CustomDepth.png)

このシーンは 2 つのオブジェクトで機能をアクティベートしていますが、ポストプロセス処理のパスはコンテンツを表示せずに、この機能は不可視のままとなります：

![](scene.png)

こちらはCustomDepthを視覚化したものになります：

![](sceneCustomDepth.png)

視覚化のために使用したマテリアルです：

![](CustomDepthMat.png)

## テンポラル アンチエイリアシングまたは GBuffer ジッター

テンポラルアンチエイリアスはUE4の特殊な機能で、わずかなパフォーマンスコストで画像品質を大幅に向上させます。

デフォルト設定で、ポストプロセス マテリアルはポストプロセスグラフの最後に挿入されています (トーンマッパ後)。つまり、トーンマッピング、カラー グレーディング、そしてテンポラル アンチエイリアシングが適用された後に
最終的な LDR カラーを受け取ります。パフォーマンスや使いやすさの観点から、多くの簡易なポストプロセス効果にとって最高のスポットです。

これは特定のオブジェクト周りのシルエットを可視化させるために使用した深度のカスタム入力値の使用例です。

![](sceneAfterTonemapper.png)

元の画像はシルエットにアンチエイリアス処理が見受けられませんが、動作中はシルエットが1ピクセル変動するのが分かります。
テンポラルアンチエイリアスは、全体シーンのレンダリングをサブピクセルの各フレームで動かすためです。アンチエイリアス処理をした最終画像を作成するために、複数のフレームが組み合わせられます。
この問題を解決するために、ポストプロセス グラフで元の場所へマテリアルを移動することもできます。

こちらが結果となります：

![](sceneBeforeTonemapper.png)

安定したアンチエイリアス処理がされた画像となります。移動中はテンポラルアンチエイリアス処理でいくつかのアーティファクトに気づくかもしれません。この機能は古い画像を置換するために深度バッファを使用しています。オブジェクトの内側のレンダリングは上手く機能しますが、
オブジェクトの外側では深度バッファを調整する必要があります（コストが余分にかかるパフォーマンスであるためまだ試していません）。TemporalAAはまだ開発途中の機能です。ここでは輪郭が太めに表示されていますが、
これは理想的ではありません。 

## UV と ScreenPos

ポストプロセス マテリアルで画面にあわせたバッファを参照することができますが、正しい UV が必要になります。 
**ScreenPosition** マテリアル式が求められた UV (ビューポートの左上が 0,0 で、右下が 1,1) を出力します。
**texture coordinate** マテリアル式を使うと、結果は異なります。これは、テクスチャ (厳密にはレンダー ターゲット) は実際はビューポートよりも大きくなる可能性があるためです。
このテクスチャを複数のビューポートで共有し、最も大きいものがすべてのビューポートで使用されるため、エディタの中では大きくなってしまう可能性があります。
ゲーム内でさえ、大きくなってしまうことがあります (SceneCaptureActors は小さいビューポート、Matienee black borders、 Splitscreen、 VR の状態になっていします)。
texture coorinate マテリアル式を使うと、大きめのテクスチャようにUV が提供されます。相対オフセット (ピクセルサイズのエッジ探知など) だけが必要な場合は、正しいサイズでスケールする必要があります。
**SceneTexture** マテリアル式には、サイズの出力とサイズの反転出力があります (ピクセル オフセットに効果的かつ便利です)。
ビューポート UV を取得したい場合 (マップ テクスチャからビューポートなど) は、 **ScreenPosition** マテリアル式を使ったり、必要な演算を手書きのコードで行う (より制御されますが遅くなることがあります) ことができます。
これを行うためには、 **ViewSize** マテリアル式が必要になります。これらすべてのテストに、様々なビューポート コンフィギュレーションをテストすることができるコンソール変数 **r.ViewPortTest** を使います。

## フィルター済みテクスチャ ルックアップ

SceneTexture マテリアル式には、 [バイリニア] でフィルタ処理したルックアップを取得するためのチェックボックスがあります。このオプションを使うと、レンダリング速度が落ちるので、必要な場合のみ使用してください。
スクリーン空間テクスチャの多くはフィルタリングをサポートしていません (GBuffer など)。このプロパティをエクスポーズしないことで、エンジンが必要に応じてデータを圧縮できるようになります (パッキングがフィルタリングを妨げます)。

## トーンマッパの置換え

[Replacing the Tonemapper] のブレンド可能な位置を使用することで、エンジン内のトーンマッパを独自のトーンマッパでオーバーライドすることができます。開発中の機能なので今後変更される場合があります。また、機能はまだ完全に実装されていません。

![](ReplacingTheTonemapper.png)

ポストプロセス設定パラメータをトーンマッパに公開し始めましたが、大幅な変更が予想されます。
値はマテリアル パラメータとして公開され、正確な名前が必要になります。 

Vector パラメータ：
	Engine.FilmWhitePoint
Scalar パラメータ
	Engine.FilmSaturation
	Engine.FilmContrast

	[EXCERPT:PostMatWarning]

[REGION:warning]
パラメータを取得するには、ポストプロセス マテリアルからマテリアル インスタンスを作成しなくてはいけません！
[/REGION]
[/EXCERPT:PostMatWarning]

独自のパラメータを使って、他のポストプロセス マテリアルのようにブレンドすることも可能です。

## 既知の問題
以下は依然として修正が必要な問題です：

  * **Material expression SceneTexture**
    * 個々の透過が機能しない点
    * 特定のルックアップが特定のパスで機能しない点 (パフォーマンスのコストが高すぎるため修正しない可能性もあります)
    * MaterialFunction がエラーを報告しても PostProcess ドメインでマテリアルに使用される点
  * **マテリアル**
    * PostProcessMaterial の UV が 0 から 1 の範囲ではない点 (例えばエディタでビューポートサイズを縮小時)。ルックアップと調整は取れるもののビネット効果のような機能とは実装が難しくなります。
    * ポストプロセス マテリアルのアセット サムネイルの見た目が正確ではない点
    * アルファ値の出力がいまだサポートされていない点 (オパシティを通過しなくてはいけません)
    * マテリアル エディタのプレビュー マテリアルの見た目が正確ではない点
    * マテリアルの変化がポストプロセス処理の変化につながらない点ワークアラウンド：エディタの再起動
	* ポストプロセス マテリアルは **コンテンツ ブラウザ** で容易なフィルタリングができなくてはいけない点
  * **ブレンド**
    * ブレンド半径で 2 つのポストプロセス ボリュームをブレンド時の移行が滑らかではない点デフォルト値であるマテリアルインスタンスを設定した非結合ボリュームを使用してこれを防ぎます。


## FAQ
  * **入力値に "ライティングのみのモード" のテクスチャを使用できますか？**

    できません。中間段階でこのデータは有効ではありません。このビューモードではマテリアルカラーを無視して
	生成しています。高速オプションにするには大部分のレンダリング コードの再構成が必要です。

  * **SceneColor のルックアップで表示されるバンディングは PostProcessInput0 の使用時に何故見えないのでしょうか？**

    SceneColorを使用時は、現在書き込んでいるテクスチャへのルックアップが可能となるように質を低下させたシーンのコピーを作成します。
	（一般的にはこの処理が不可能なメッシュへレンダリングしています）
	ポストプロセス処理には PostProcessInput0 を使用しなくてはいけません。

  * **ポストプロセス処理に必要なメモリ使用量はどの位ですか？**

    メモリーの使用コストはスクリーンの解像度次第です。トーンマッピング処理の前に HDR (ピクセルあたり 8 バイト)、その後 LDR (ピクセルあたり 4 バイト) を使用します。

  * **ポストプロセスのレンダリング負荷はどうやったら低くできますか？?**

    ターゲットプラットフォームで測定、テクスチャルックアップ数を低めに維持、より少ない演算操作および依存テクスチャルックアップの削減、
	ランダム化したテクスチャルックアップの回避 (テクスチャのキャッシュ ミスが原因で遅くなっている可能性があります)。

  * **パスはいくつ使用できますか？**

    パスの使用ひとつひとつがパフォーマンスコストへ加算されます。パスの結合とパスのアクティベートは必要時のみにとどめてください。一般的なゲーム機能。
	例えばより良いパフォーマンスのために、エンジンパスへノイズを追加するなど。

  * **ポストプロセス処理およびブレンドにかかるCPUのパフォーマンスコストはどのくらいですか？**

    マテリアルのブレンドは非常に低コストです。すべてのマテリアル インスタンスのプロパティは、ブレンドされ、こうした設定を持つひとつのポストプロセス マテリアルのパスだけがレンダリングされます。

  * **正確なTemporalAAのために"Before Tonemapper" を使用したいです。カラーを使用するとトーンマッピングされてしまい、違った見た目となってしまいます。どうやってこの問題を回避できますか？**
    
	この問題に対する簡単な解決法はありません。逆のトーンマッピング演算 (高コスト) をする必要があります。目の順応によっては、
	さらに異なった色で表示されるかもしれません。EyeAdaptation レベルを SceneTextures へ公開してこれを補正します。

  * **どうやってポストプロセスグラフの全ダンプ内容を取得できますか？**

	**r.CompositionGraphDebug** でグラフのログをコンソールへ記録することができます。例:

		FRenderingCompositePassContext:Debug 'PostProcessing' ---------
		Node#1 'SceneColor'
			ePId_Output0 (2D 1136x768 PF_FloatRGBA RT) SceneColor Dep:2
		Node#4 'Velocity'
			ePId_Output0 (2D 1136x768 PF_G16R16 RT) Velocity Dep:1
		Node#2 'SceneDepthZ'
			ePId_Output0 (2D 1136x768 PF_DepthStencil) SceneDepthZ Dep:1
		Node#5 'MotionBlurSetup0MotionBlurSetup1'
			ePId_Input0:Node#4 @ ePId_Output0 'Velocity'
			ePId_Input1:Node#1 @ ePId_Output0 'SceneColor'
			ePId_Input2:Node#2 @ ePId_Output0 'SceneDepthZ'
			ePId_Output0 (2D 568x384 PF_FloatRGBA RT) MotionBlurSetup0 Dep:2
			ePId_Output1 (2D 568x384 PF_FloatRGBA RT) MotionBlurSetup1 Dep:1
		Node#6 'QuarterResVelocity'
			ePId_Input0:Node#5 @ ePId_Output0 'MotionBlurSetup0MotionBlurSetup1'
			ePId_Input1:
			ePId_Output0 (2D 284x192 PF_FloatRGBA RT) QuarterResVelocity Dep:1
		Node#7 'VelocityBlurX'
			ePId_Input0:Node#6 @ ePId_Output0 'QuarterResVelocity'
			ePId_Input1:
			ePId_Output0 (2D 284x192 PF_FloatRGBA RT) VelocityBlurX Dep:1
		...


