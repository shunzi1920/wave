INTSourceChangelist:2602715
Availability:Public
Title: 환경에 똑똑한 질문하기
Crumbs:%ROOT%, Engine, Gameplay/AI, Engine/AI/EnvironmentQuerySystem
Description:시니어 AI 프로그래머 Mieszko Zielinski 가 인바이언먼트 쿼리 시스템의 전신인 인바이언먼트 택티컬 쿼리에 대해 작성한 백서입니다.

[VAR:Topic]
[OBJECT:Topic]
	[PARAM:image]
		![%Engine/AI/EnvironmentQuerySystem/AskingSmartQuestions:title%](AI_Topic.png)
	[/PARAM]
	[PARAM:icon]
		![](%ROOT%/start_icon.png)(convert:false)
	[/PARAM]
	[PARAM:title]
		%Engine/AI/EnvironmentQuerySystem/AskingSmartQuestions:title%
	[/PARAM]
	[PARAM:description]
		%Engine/AI/EnvironmentQuerySystem/AskingSmartQuestions:description%
	[/PARAM]
	[PARAM:path]
		[RELATIVE:Engine/AI/EnvironmentQuerySystem/AskingSmartQuestions]
	[/PARAM]
[/OBJECT]
[/VAR]
[VAR:TopicCompact]
[OBJECT:TopicCompact]
	[PARAM:image]
		![%Engine/AI/EnvironmentQuerySystem/AskingSmartQuestions:title%](AI_Topic.png)
	[/PARAM]
	[PARAM:icon]
		![](%ROOT%/start_icon.png)(convert:false)
	[/PARAM]
	[PARAM:title]
		%Engine/AI/EnvironmentQuerySystem/AskingSmartQuestions:title%
	[/PARAM]
	[PARAM:description]
		%Engine/AI/EnvironmentQuerySystem/AskingSmartQuestions:description%
	[/PARAM]
	[PARAM:path]
		[RELATIVE:Engine/AI/EnvironmentQuerySystem/AskingSmartQuestions]
	[/PARAM]
[/OBJECT]
[/VAR]

[toc]

## 서문

이 문서는 시니어 AI 프로그래머 Mieszko Zielinski 가 **Bulletstorm** 재직 당시 작성한 백서로, 인바이언먼트 쿼리 시스템 (**EQS**) 에 대한 근본 개념을 아우릅니다. 언리얼 엔진 4 의 **EQS** 전신인 **Bulletstorm** 의 인바이언먼트 택티컬 쿼리 (**ETQ**) 시스템을 참조하고 있습니다.

## x.1 소개

슈팅 게임과 같은 복잡한 동적 환경에서 길을 찾는 것은 험난한 과제로, 매 프레임 사용할 수 있는 CPU 틱이 얼마 되지 않는 AI 액터라면 특히나 더욱 그렇습니다. 삶은 고단하지요. "어디로 갈 지 어떻게 알아? 갈 곳이 천지인데 어디가 나은지 어떻게 알아? 오! 적이다! 둘! 셋씩이나! 누구를 먼저 쏘지?"

AI 에 필요한 데이터를 전부 제공해 주는 서비스를, 적은 CPU 시간 비용에, 유연하면서 사용하기도 쉽게 만드는 것도 까다로운 작업입니다. 다양한 것들을 둘러보고, 필터를 적용한 다음 스코어 작업을 해 줘야 합니다. 불릿스톰에서 저희는, CPU 시간을 많이 잡아먹지 않으면서 디자이너에게도 직관적인 AI 공간 인식 필요성을 전부 담당하는 시스템을 만들었습니다. 시스템이 쉽게 이해할 수 있는 비직관적 데이터를 사람이 만들도록 하는 대신, 사람이 쉽게 이해할 수 있는 입력을 받는 시스템을 만드는 데 집중했습니다.

## x.2 동기

불릿스톰 개발 초기, 두 가지 새로운 시스템을 디자인하여 구현했습니다. 하나는 AI 의 로직 (우리 비헤이비어 트리 구현), 다른 하나는 중앙 집중형 인바이언먼트 쿼리 시스템입니다. 이 글에서는 후자의 시스템, 소위 인바이언먼트 택티컬 쿼리 (줄여서 ETQ) 시스템에 대해 논해보도록 하겠습니다.

불릿스톰의 인바이언먼탈 쿼리는 두 가지 형태로 나타납니다. 사물의 유형과 속성에 따른 것이지요. "적", "커버", "위치" 는 "사물의 유형" 에 대한 예제입니다. "내비메시 위에", "적에게 보이지 않음", "리더에서 일정 거리 이탈" 등은 속성의 예제입니다. 선호도의 형태를 띨 수도 있습니다. "보이지 않는 것들 선호", "나에게 가까운 것 선호" 식입니다.

## x.3 목표

시스템 전체 수명에 걸쳐 이루고자 하는 여러가지 목표를 설정했습니다.

* **"어떻게 물을 것인가"가 아니라 "무엇을 물을 것인가"를 생각** - 질문을 만들고 묻는 것은 가급적 단순하게 해야 할 것입니다. 창의성을 가로막는 것은 없기를 바랬지요.
* **프로그래머가 아니어도 가능하도록** - 처음부터 디자이너를 위한 전용 에디터를 만들고자 했습니다. 그래서 AI 가 커버나 적을 선택하는 방식을 변경하고자 하는 경우 클릭만으로 직접 할 수 있도록 하고자 했습니다.
* **코드 재사용성** - 저희의 주요 코딩 십계명으로, 정말 깨끗하고 말끔한 코드가 되었습니다.
* **퍼포먼스** - 다른 시스템에 퍼포먼스 영향을 전혀 주지 않고도 임무를 수행할 수 있도록 하는 것이 이 시스템에 있어 매우 중요한 것이었습니다.
* **비동기성** - ETQ 시스템 자체는 게임 스레드에서 실행중이라 할지라도, 올라온 질문이 답변을 바로 기다리느라 게임을 막지 않도록 비동기성으로 만들었습니다. 대신 시스템이 쿼리 프로세싱을 시스템 정기 업데이트 도중 수행되도록 스케쥴을 짰습니다. 그를 통해 메인 쿼리 프로세싱 루프를 시간 단위로 자르는 것이 가능했습니다.

## x.4 저희의 철학

자신에게 간단한 질문을 하는 것으로 쿼리를 만들 수 있도록 하는 이상적인 데디터 제작기를 원했습니다:

* **무엇을 생성할 것인가?** - 커버, 적 위치, 지점 등 게임 월드에서 위치가 있는 무엇이든 될 수 있습니다.
* **누가 묻는가?** - 쿼리의 컨텍스트 오브젝트는 무엇인가, 어느 개체가 질문하고 있는가. 그것은 거의 AI 액터인 경우가 많았지만, AI 가 추적중인 적(이 어디로 갈 수 있지?), 커버, 스폰 지점에 대한 질문도 가능합니다.
* **어디를 살펴볼 것인가?** - 후보 아이템에 대한 공간적 제약은 무엇인가? 예를 들면 컨텍스트 오브젝트 주변 일정 반경 또는 오브젝트에 할당된 전투 지역 내 아이템을 생성할 수 있었습니다.
* **어떤 아이템이 괜찮은가?** - 수용할 수 있는 아이템의 최저 기준은 무엇인가? 어떤 레퍼런스 오브젝트에서 보이는 아이템이어야 할 수도 있고, 컨텍스트 오브젝트에서 X 보다 가까운 아이템은 안될 수도 있는데, 이러한 것들이 조건을 이루었습니다.
* **어느 아이템이 나은가?** - 어느 아이템이 다른 것보다 나은지 어떻게 알 수 있을까요? 무언가에 가깝거나 먼 아이템을 선호할 수도 있고, 어떤 속성을 가진 아이템을 선호할 수도 있고, 어떤 프로퍼티의 값이 설정된 한계치보다 낮은 것을 선호할 수도 있습니다.

## x.5	해부도

ETQ 시스템은 데이터 주도형 솔루션으로, 그 위력은 대부분 데이터 표현 방식의 디자인에서 나옵니다. 매우 유연하면서도 효율적으로 만들도록 많이 생각하고 주의를 기울였습니다. 디자인의 세세한 부분을 조금 더 자세히 들여다 볼 차례입니다.

### x.5.1	쿼리

하나의 쿼리는 크게 세 가지 성분으로 나뉩니다:

* **컨텍스트 오브젝트** - 질문을 하는(, 좀 더 정확히 질문을 받는 대상을 대신하는) 게임 개체인가? 이 쿼리의 공간적 맥락은 무엇인가? 이러한 부분이 매우 중요한데, 이 액터의 속성이 주관적인 세계관을 정의하는데 사용될 것이기 때문입니다. 이를테면 "저 지점이 여기서 보이는가", "그게 내 시야 안에 있는가" 식입니다. 참고로 컨텍스트 오브젝트가 AI 액터일 필요는 없습니다.
* **쿼리 템플릿 ID** - 어떠한 사용자 생성 질문을 하고 있는가? 시스템에 등록된 모든 쿼리 템플릿에는 고유 id 가 있으며, 여기서 무엇을 사용할지 나타냅니다.
* **아이템** - 찾은 모든 아이템을 넣고, 그에 따라 잇따른 필터링 테스트를 실패하는 모든 아이템을 제거하는 곳입니다.

쿼리 프로세싱을 발동시키기 위해, ETQ 시스템을 호출하면서 어떤 쿼리 템플릿을 실행시킬지, 그 쿼리의 공간 및 게임플레이 컨텍스트는 무엇인지에 대한 정보를 제공합니다. 쿼리 프로세싱을 백그라운드 보다는 즉시 이루어지도록 요청할 수도 있습니다.

### x.5.2 쿼리 템플릿

실행시간에 질문을 어떻게 할지는 알았지만, 질문을 어떻게 정의할까요? 무엇을 찾고 있는지와 "좋은 아이템"이 갖고 있는 속성 중 무엇에 관심이 있는지 표현을 해야 합니다. 아이템 스코어를 위해 다른 것을 사용하면서도 몇몇 프로퍼티는 필요로 할 수도 있습니다.

질문은 자체 제작한 특수한 툴로 에디터에서 정의되며, 일반적인 애셋으로 저장됩니다. 이 애셋은 코드에서 Query Template, 쿼리 템플릿이라고 합니다. 쿼리 템플릿은 하나 이상의 옵션으로 구성되며, 이 옵션은 차례로 다수의 테스트로 구성됩니다.

먼저, 쿼리 템플릿은 나중 단계에서 처리될 아이템 채우기를 생성하는 법에 대한 정보가 들어있는 옵션을 정의합니다. 이는 게임 월드에서 개체를 나타내는 아이템 모음을 만듭니다. 제너레이터를 다수 구현했는데, 예를 들면:

* **컨텍스트 오브젝트의 적** - 주어진 AI 가 인식하고 있는 모든 적을 수집합니다.
* **커버** - 파라미터화된 컨텍스트 오브젝트의 반경 내 커버 포인트 모음 결과입니다.
* **그리드 상의 지점** - 컨텍스트 오브젝트 주변 환경설정 가능한 그리드상의 지점을 생성합니다.

ETQ 는 새로운 제너레이터 저작을 매우 쉽게 만들어 주어, 가끔은 코드 두 세 줄이면 가능합니다.

쿼리 템플릿의 옵션에 대한 제너레이터가 설정되면, 그 아이템에 대한 필터링 및 스코어링 방법을 지정합니다. 아이템은 "테스트" 를 통해 조건으로 걸러내고 스코어를 기록합니다. 목록 x.1 의사 코드에서 테스트 구조체를 살펴보세요. 테스트 구조체는 테스트할 속성 (TestType), 테스트에 대한 레퍼런스 목록 (Reference), 비교 유형 (ConditionModifier), 비교 대상 값 (TestedValue) 을 나타냅니다. 스코어에 사용되는 경우 테스트에 가중치(weight)를 할당할 수도 있습니다.

	struct Test
	{
		TestType;      	// 거리, 도달가능성...
		ConditionModifier;  	// 없음, 최소, 최대
		Reference;     	// 자신, 적, 리더, 아이템, ...
		TestedValue;   	// float, int, bool, ... 
		SymbolicValue; 	// 근접 거리, 무기 거리, ...
		Weight;   	// [-1,1] 범위 float
		/** flags */
		bCondition;    	// 불리언 플래그, 
				// 이 테스트가 조건,
		bValidityTest; 	// 밑/또는 유효성 테스트 (x.5.3 참고),
		bWeight;  		// 또는 가중치로 사용됨을 나타냄.
	} 
	
_목록 x.1 테스트 구조체 의사 코드_

테스트 구성 순서는 중요치 않습니다 - 테스트는 ("무엇이 무엇보다 비싼지"에 대한 비교 목록으로 프로그래머가 측정하는) 계산 비용에 따라 (자세한 내용은 섹션 x.7 참고), 그리고 조건인지 단순한 스코어 테스트인지에 따라 순서가 결정됩니다. 가장 비싼 테스트도 다른 스코어 작업이 벌어지기 전 일어날 수 있어, 스코어 작업에는 시간이 덜 걸릴 수 있지만 이게 결과적으로 시간을 절약할 지는 논란의 여지가 있습니다. 이 문제는 섹션 x.10 의 "최종 테스트" 에서 다룹니다.

테스트에 제한이 너무 많아 조건을 통과하는 아이템이 없는 경우, 전체 쿼리에 그냥 실패하도록 놔두기 보다는 제약을 완화시키는 것이 좋을 것입니다. 시스템에서는 이러한 경우를 지원합니다. 쿼리 템플릿에 옵션이 하나 이상 있다면, 쿼리의 결과가 되는 아이템을 몇 만들어내는 것이 있을 때까지 시퀀스로 모두 처리합니다.
	
### x.5.3 유효성 테스트

쿼리 템플릿의 옵션에 선언된 테스트는 조건이나 가중치, 또는 둘 다 될 수 있습니다. 하지만 ETQ 에서는 특정 테스트를 "validity test", 유효성 테스트로 지정할 수 있습니다. 이 테스트는 커버 생성 시간이 아닌 그 이후, AI 가 그 커버로 이동중이거나 그 안에 앉아있을 때, 이 커버가 여전히 유효한지 (예를 들면 적의 발사에 노출되지 않았는지) 검사하기 위해 사용됩니다. 물론 이 테스트는 일반 테스트임과 동시에 유효성 테스트가 될 수도 있습니다. 이런식으로 커버 지점 선택 방법에 대한 모든 환경설정 정보와, 나중에도 그것이 (종종 그렇지 않은 경우가 있기에) 여전히 괜찮은지에 대한 정보가 한 곳에 이쁘게 모입니다. 문제가 되는 그 한 아이템에 쿼리를 다시 실행함으로써 같은 함수성을 얻어낼 수 있지만, 진행형 유효성 검사 실행 도중에는 필요치 않을 테스트가 다수 생길 것입니다. 유효성 테스트만을 위한 별도의 경량 쿼리를 만들 수도 있지만, 그것은 두 쿼리 중 하나가 바뀔 때마다 동기 상태를 유지시켜야 할 것입니다. 몇몇 테스트를 유효성 테스트로 만드는 것이 양쪽 세계에 최선입니다. 진행형 테스팅 도중에는 필요한 테스트만 하는 반면, 동시에 아이템 선택 및 진행형 유효성 검사 로직 전부 한 쿼리 애셋에 몰아두는 것입니다.

### x.5.4 어떤 역할에도 하나의 테스트로
모든 테스트에 멋진 통합 인터페이스를 갖기 위해서, 모든 테스트가 조건으로도 가중치로도, 양쪽 역할에 맞도록 만들기로 결정했습니다. 예를 들어 "적과의 거리" 를 조건으로 사용한다면, 2000 유닛 미만이 되도록 요구할 수 있습니다. 하지만 가중치로 사용한다면 적과의 거리가 이보다 작거나 큰 것을 선호하는 것으로 해석합니다. 테스트의 가중치 값을 설정하는 것으로 테스트한 속성을 얼마만큼 선호하는지를 표현합니다. 값이 클 수록 주어진 속성을 선호하는 것입니다. 추가 예제는 표 x.1 과 같습니다.

| 테스트 | 조건 | 가중치 |
| --- | --- | --- | 
| 표시여부 | (안)보이는지 | (안)보이는 것을 선호 |
| 거리 | X 초과/미만/동일 | 더 멀리/가까기 있는 것을 선호 |
| 환경설정가능 도트 | X 초과/미만/동일 | 초과/미만 선호 |
| 동작 반경 내 | 동작 반경 내에 (안)있는지 | 동작 반경 내에 있는 것을 선호 (않음) |
| 도달가능 | 길찾기로 도달가능한지 (아닌지) | 도달가능 (비)선호 |
| 벽까지 거리 | X 초과/미만/동일 | 초과/미만 선호 |
| 현재 아이템 | 현재 아이템인지 (아닌지) | 현재 아이템 (비)선호 |
	
_표 X.1 다양한 테스트가 조건 및 가중치로 사용될 떄의 예를 보여줍니다._

## x.6 정수

코어 ETQ 알고리즘을 아래 의사 코드에 담아봤습니다.

	foreach Option in QueryTemplate.Options:
		Query.Items = (generate items with QueryTemplate.Generator 
					   using contextual data from Query);
		if Query.Items is empty:
			continue to next option;
		foreach Test in Option.Tests:
			Reference = (find world object Test refers to);
			if Reference not empty or not required by Test:
				// this is explained in section X.7 under "Fail Quickly"
				if Test has a fixed result:	
					apply result to all Query.Item elements;
				else:
					perform Test on all Query.Item elements;
				if Test.bCondition is true:
					filter out all Query.Item elements that failed Test;
				if Test.bWeight is true:
					foreach Item in Query.Item:
						calculate weights from every test result
		if Query.Items not empty:
			foreach Item in Query.Items:
				sum up all weights calculated by weighting tests;
			sort Query.Items descending with computed weight;
			return success;
	return failure;
	
_목록 x.2 코어 ETQ 쿼리 알고리즘_

## x.7 구현 디테일

아주 단순한 알고리즘을 구현할지라도 부릴 수 있는 꼼수는 항상 있습니다. 저희의 경우는 이랬습니다.

* **싼 테스트로 시작** - 예상되는 퍼포먼스에 따라 테스트 유형을 수동으로 미리 소팅했습니다. 예를 들어, 거리 테스트가 액터에 태그가 있는지 검사하는 것보다는 비싸지만, 한 지점이 내비메시에 있는지 알아내는 것보다는 비싸지 않습니다.
* **빠르게 실패** - 어떤 테스트는 더욱 넓은 쿼리 컨텍스트에 따라 모든 아이템에 대해 같은 결과를 내도록 하는 것이 가능합니다. 예를 들어 한 지점이 내비메시에 있는가 하는 검사는 내비메시가 없다면 항상 실패할 것입니다. 분대 리더나 적의 경우처럼, 주어진 컨텍스트에 존재하지 않는 레퍼런스를 필요로 하는 테스트의 경우, 더욱 일찍 실패하는 것도 가능합니다.
* **테스트 결과 및 가중치 정규화** - "속성 있음" 유형의 테스트에 대해 거리 테스트의 가중치를 매기려 해 봐야 불가능하다는 것을 일찍 발견했습니다. 최대 거리를 아는 상태에서 가능은 하다 치더라도, 최대값을 변경하면 바로 떨어져 나와 재조정이 필요할 것입니다. 그래서 모든 테스트 결과를 정규화시키기로 결정했습니다. 테스트 수행 도중에는 최대 결과 값을 저장하고, 테스트가 완료되면 모든 결과를 저장된 최대치로 정규화시키는 것입니다. 어떤 경우에는 처리된 옵션의 아이템 생성 범위를 사용하기도 해야 할 것입니다. 가중치가 항당 (에디터를 통해) `[-1,1]` 범위에 있도록 하여, 결과 정규화와 함께 적당한 수학적 속성을 얻고 안전한 쿼리 트윅 작업이 가능했습니다.
* **가급적 디버그 드로** - 디버그 드로의 중요성은 너무나도 중요합니다. 이런 시스템을 개발하는 도중에는 어느 타겟의 어느 쿼리든지 실행시간 도중에 발동시킬 수 있어야 하며, 그 결과를 확인할 수 있어야 합니다. 쿼리의 디버그 드로잉만으로 셀 수도 없이 많은 버그를 찾아냈기에, 엄청난 시간 절약이 가능했습니다.

## x.8 에디터

언리얼 엔진 3 의 툴 제작 편의성을 활용하여, ETQ 용 툴을 만들었습니다. 툴을 사용하니 쿼리 애셋 작업이 훨씬 수월해 졌으며, 그에 대한 직접적인 결과로 쿼리 작업을 하면서 수정한 뒤 무언가 잘못되었는지를 바로 확인할 수가 있었습니다. 도표 x.1  은 에디터의 쿼리 템플릿과 옵션 예제 및 테스트 노드의 속성을 보여줍니다.

툴에서 추가로 제공한 기능은 다음과 같습니다:

* **가중치 자동 스케일 조절** - 테스트의 가중치가 [-1,1] 범위 이외의 값으로 변할 때마다, 에디터가 모든 가중치를 주어진 쿼리 옵션 비율에 따라 구현 부분에 언급된 범위에 맞도록 스케일을 재조절합니다.
* **비주얼 자동 배치** - 쿼리는 나무같은 구조로 표현됩니다. 테스트 시각화에 사용된 모든 요소는 옵션 노드를 제목으로 하는 열에 넣어, 누가 만들었는지 상관 없이 모든 질의에 통일된 모습을 내도록 했습니다. 다른 누군가의 쿼리에 자신의 방법을 찾기가 훨씬 쉬워졌습니다.
* **설명이 되는 라벨** - 쿼리 애셋의 모든 테스트 노드에 프로그래머가 아닌 사람도 그 자체로 이해할 수 있는 설명을 달도록 하고, 에디터의 시각화에 표시되도록 했습니다. 즉 예를 들어 "리더가 길찾기할 직선이 있음" (조건) 또는 "컨텍스트 오브젝트까지의 거리, 미만을 선호" (가중치) 같은 라벨을 만들었습니다. 익숙하지 않은 사람조차 그냥 보기만 해도 어떤 질의인지 알 수 있도록 하고자 하는 생각이었습니다.
* **컬러링** - 꽤나 명확한 부분이지만, 셋업이 잘못되었거나 값이 빠진 것들은 전부 노랑색을 (다른 모든 것들은 어두운 색을) 입혔습니다. 이런 식으로 어떤 쿼리가 깨졌는지 한 눈에 바로 알 수 있었습니다.

## x.9 장단점

ETQ 에는 여러가지 장점이 있었습니다. 예를 들자면:

* **직관적 쿼리 생성** - 이 툴을 가지고 디자이너조차도 최소한의 교육을 통해 쿼리를 만들 수 있었습니다. 개념 자체가 사람들이 질문을 표현하는 방식과 비슷해서, 기술적 배경이 적은 디자이너도 이해하는 데 어려움이 없었습니다.
* **데이터 주도형** - 데이터가 코드 작동 방식을 제어하도록 하는 것이야말로 게임 개발의 성배입니다. 예를 들어 프로그래머는 AI 가 적이나 커버를 선택하는 방식을 변경하는 모든 작업에 관여할 필요가 더이상 없는 것입니다.
* **효율성** - 시스템에 타임 슬라이스 방식을 적용하면서, 쿼리 셋업의 아이템 수가 미칠듯이 생성되지 않게 되어, ETQ 의 프레임당 평균 처리 속도를 0.02 ms 아래로 짜내면서도, 매우 정교한 쿼리를 통해 특정 속성의 게임 개체를 찾을 수 있었습니다.
* **유연성** - 새로운 테스트와 제너레이터 추가가 정말 쉬워서, 누구든 현재 테스트나 제너레이터에서 제공하지 않는 작업을 해야 할 때마다, 새로 추가하는 것이 괴롭지 않았습니다. 추가하기가 매우 쉬우면서, (타임 슬라이스로 인해) 실행시간에 매우 효율적입니다.

ETQ 의 주요한 문제점은, 쿼리가 원하는 대로 생성되도록 하기 위해서는 트윅 작업에 약간의 시간 내지 경험이 필요할 수 있다는 점입니다. 반면, 쿼리 작업 도중의 반복처리 작업이 매우 빨랐고 (전용 런타임 툴도 마련되어 있습니다) 비숙련 사용자도 정말 금방 필요한 직관을 얻을 수 있었습니다.

"Gears of War: Judgment" 에도 ETQ 시스템을 사용했습니다. 여러 태스크에 적용되었으며, 몇 가지 문제점이 있었습니다. 그 중 한 가지는, 특정 상황에서 CPU 사용량이 15ms 까지 치솟는 것이었습니다. 커대한 아이템 집합에 비싼 테스트를 수행했기 때문이었는데, 아이템 단일 집합에 대한 각 테스트를 원자적으로 취급하여 타임 슬라이스를 적용하지 않았기 때문입니다. 이러한 급등은 쿼리 제너레이터가 레벨에 배치된 개체(이 경우 "골 액터"), 즉 레벨 디자이너가 설정한 값으로부터 커버 수집 범위를 읽었기 때문입니다. 이는 사실 데이터 주도형 시스템에 내재된 문제로, 디자이너가 입력한 값이 시스템의 퍼포먼스를 죽이지는 않는지 주의가 필요합니다. 반경을 경험에 기반한 최대값으로 제한시키는 것으로 간단히 고쳤습니다.

## x.10 수정 및 개선점

불릿스톰 최종 출하 단계까지도 해내지 못했던 개선점이 다수 있었습니다. 거기에는:

* **테스트 병합** - 특정 테스트는 그룹으로 나타나는 경향을 띄는데, 예를 들어 커버 포인트에 대해 "X 이상의 적에 대한 dot product", "Y 이상의 적까지의 거리", "내 현재 커버 아님" 식입니다. 직관적으로 볼 때 이러한 것을 차례차례 이어서 하는 것보다는, 이 모든 것들을 한 번에 하는 테스트를 두는 것이 훨씬 이치에 맞을 것입니다.
* **최종 테스트** - 종종 엄청난 갯수의 필터로도 테스트 아이템 총 갯수를 적당한 수준만큼 낮출 수가 없는 경우가 있습니다. 처리할 아이템이 너무 많아 비싼 테스트를 해야 하는 지경에 이르면, 퍼포먼스가 조악했습니다. "최종 테스트" 라는 개념은, 그 테스트를 통과하는 아이템이 N 개 나오면 나머지에 대해서는 종료해 버리는 것입니다. 최종 테스트는 말 그대로 최후의 보루로 처리해야할 것으로, 이를 통해 모든 아이템에 대해 비싼 테스트 계산을 하지 않고도 충분히 괜찮은 결과를 얻을 수 있었습니다.
* **역순 처리** - [Robert 11] 이 현재 AI 가 사용하는 커버 선택 방식보다 나은 것을 알려줬습니다. 같은 것을 ETQ 에도 추가했습니다. 그래서 쿼리의 일반적인 처리를 실행하는 것 대신 AI 의 현재 커버 포인트를 잡아, 먼저 등급을 매긴 다음, 쿼리의 필터 전부를 통과하고 스코어가 높은 첫 아이템을 수락하는 것입니다.
* **다중 제너레이터** - 쿼리 템플릿에 다중 제너레이터를 사용할 수 있도록 함으로써 다양한 아이템 집합에 대한 통합 테스트를 (일반 지점과 커버 지점에 대한 테스트를 한 번에) 실행할 수 있게 되었습니다.
* **멀티스레드 구현** - ETQ 를 별도의 스레드에 실행시킬 필요도, CPU 리소스도 없었지만, 프로그램에 쓸 수 있는 CPU 코어 갯수가 늘어나면서 미래를 바라보는 것이 되었습니다.

## x.11 결론

설명한 시스템이 디자인상으로는 매우 단순했지만, 매우 강력한 것으로 증명되었습니다. CPU 시간을 많이 잡아먹지 않고도 엄청난 인바이언먼트 쿼리 파워를 얻게 되었습니다. ETQ 를 데이터 주도형으로 만들고 쿼리를 전용 저작 툴로 만들 수 있도록 함으로써, AI 의 적 또는 커버 선택에 대해 매우 빠른 반복처리 작업이 가능했으며, 이는 실행시간 디버깅 툴을 통해 한층 더 빨라졌습니다.
더욱 높은 수준에서의 이득도 있습니다. 맨 처음서부터 ETQ 를 비동기 서비스로 생각하고 있었는데, 나머지 AI 시스템 컴포넌트도 비동기로 만드는 데 도움이 됐습니다. 비동기 AI 시스템을 디자인하고 구현하는 것은 "예전 방식"과는 약간 다른 사고방식이 필요하지만, 앞으로는 필수가 될 멀티 코어에 유동적으로 들어맞는 솔루션이 됩니다.

## x.12 감사

이 글을 쓸 수 있도록 해 준 제 아내 Agata 에게 감사드리고자 합니다. 불릿스톰 AI 에 제 미친 생각을 낼 수 있도록 도와주신 Lukasz Furman 에게도 감사 말씀 올립니다.

## x.13 참고문헌

\[Robert 11\] Gabriel Robert "Cover Selection Optimizations in GHOST RECON" Paris AI Conference Shooter Symposium 2011

## x.14 글 개요

이 글은 커버 지점, 적, 기타 개체 유형에 대한 게임 환경 질의시 유연하고 효율적인 방식을 제공하기 위해 불릿스톰에 구현한 시스템에 대한 설명입니다. 영역의 커버 리스트를 어떻게 생성했는가? 주어진 AI 액터에 가장 좋은 커버를 어떻게 알 수 있는가? 이 글은 쿼리 시스템인 ETQ 및 쿼리를 구체화시키는 데 있어 직관적이고 유연한 방식으로 접근하는 법을 설명합니다. 사용된 알고리즘에 대한 하이 레벨의 개요도 설명합니다. 구현 꼼수 몇 가지는 물론 앞으로의 개발 방향도 공유합니다.

## x.15 각 저자 약력

Mieszko Zielinski

People Can Fly 의 시니어 AI 프로그래머 Mieszko Zielinski 는 거의 십년간 게임 개발을 해 오고 있습니다. 2003 년, Aidem Media 라는 작은 스튜디오에 참가하면서 업계에 발을 들였습니다. 그 이후 CD Projekt Red, Crytek, People Can Fly 에서 재직했으며, PCF 에서는 뛰어난 프래그래머 팀과 함께 "불릿스톰" AI 시스템을 거의 처음서부터 개발했습니다. 현재 에픽 게임스의 언리얼 엔진 4 AI 시스템 요소를 개발중입니다.

은퇴하긴 했지만 폴란드 킥복싱 챔피언이었으니, 시비걸지 마세요! ;)
