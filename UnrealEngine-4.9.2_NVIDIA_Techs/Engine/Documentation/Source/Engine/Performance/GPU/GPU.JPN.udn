INTSourceChangelist:2328961
Availability:Public
Title:GPU プロファイリング
Crumbs: %ROOT%, Engine
Description:ゲームの GPU デマンドを最適化する方法
Navigation:topic

GPU では多くのユニットが平行して動いており、フレームの異なるパーツに対して異なるユニットで結合されることが一般的です。
このような事情から、ボトルネック (**何が**) を探す時はパーツ (**どこで**) を見るとうまくいきます。

## GPU 負荷を特定する

**ProfileGPU** コマンドにより、各種パス、そして時にはドローコールまでへも掘り下げて GPU 負荷をすぐに特定することができます。
マウスベースの UI またはテキストバージョンのいずれかを使用できます。**r.ProfileGPU.ShowUI** で UI を非表示にすることができます。データは GPU タイムスタンプに基いており、
通常とても正確です。最適化をすると数字の信頼性が落ちる場合もあるので、数字を厳しく見るのが理想です。ドライバーの中には、シェーダー使用後の数秒でシェーダー負荷を最適化するものもあることが分かりました。
これは非常に分かりやすく、確信を得るために、少し待ったり、もう少し時間を測定するのに便利です。 

[REGION:imagetable]
| ![](ProfileGPU.png)(w:474) |
| :----: | 
| CONSOLE:ProfileGPU |
| Shortcut:Ctrl Shift , |
[/REGION]

    ...
     1.2% 0.13ms   ClearTranslucentVolumeLighting 1 draws 128 prims 256 verts
    42.4% 4.68ms   Lights 0 draws 0 prims 0 verts
       42.4% 4.68ms   DirectLighting 0 draws 0 prims 0 verts
           0.8% 0.09ms   NonShadowedLights 0 draws 0 prims 0 verts
              0.7% 0.08ms   StandardDeferredLighting 3 draws 0 prims 0 verts
              0.1% 0.01ms   InjectNonShadowedTranslucentLighting 6 draws 120 prims 240 verts
          12.3% 1.36ms   RenderTestMap.DirectionalLightImmovable_1 1 draws 0 prims 0 verts
              1.4% 0.15ms   TranslucencyShadowMapGeneration 0 draws 0 prims 0 verts
    ...

[REGION:note]
ProfileGPU は、アーティストは正しい光源を最適化しやすいようにライト名を表示します。
[/REGION]

フレームごとにおおまかな負荷を調べて、妥当な負荷を検討するのは意味があります (重たいドローコール、複雑なマテリアル、高密度のトライアングル メッシュ、遠い表示距離など)。

* EarlyZPass:当社ではデフォルトで z パスを使います。DBuffer デカールはフルの Z パスを要求します。これは、 **r.EarlyZPass** と **r.EarlyZPassMovable** でカスタム化が可能です。
* 基本のパス:ディファードを使用すると、単純なマテリアルは帯域幅の制約を受ける可能性があります。実際の頂点とピクセル シェーダーは、マテリアル グラムで定義されます。動的オブジェクト上に間接光がある場合、負荷が増加します。
* シャドウマップのレンダリング：実際の頂点とピクセル シェーダーは、マテリアル グラムで定義されます。ピクセル シェーダーは、マスクされたマテリアル、あるいは透過マテリアルのみに使用されます。
* シャドウ プロジェクション/ フィルタリング：**r.ShadowQuality** でシェーダー負荷を調整します。ほとんどのライト上に投影されているシャドウを無効にします。静的ライトか固定ライトかを考慮します。
* オクルージョン カリング：HZB オクルージョンの負荷は常に高いですが、オブジェクト当たりの負荷は小さめです。**r.HZBOcclusion** を切り替えて、オンにしなくても大丈夫が確認します。
* ディファード ライティング：接したピクセルに比例し、ライトの機能、 IES プロファイル、シャドウの受け取り、エリアライト、複雑なシェーディング モデルが加わるとさらに負荷が大きくなります。
* タイル処理されたディファード ライティング：**r.TiledDeferredShading** を切り替えて GPU ライトを無効にするか、 **r.TiledDeferredShading.MinimumCount** を使ってタイル処理メソッドまたは非ディファード メソッドをいつ使用するか定義します。
* 環境反射:**r.NoTiledReflections** を切り替えて、プローブがほとんどない場合を除き通常は遅めのタイル処理以外のメソッドを使います。
* アンビエント オクルージョン：品質の調整が可能で、効率的な大きいエフェクトに対して複数のパスを使用できます。
* ポストプロセス：パスによってはシェアされているので、表示フラグを切り替えて、そのエフェクトがパフォーマンスに価値があるかを確認します。

それらの次のパス上にエフェクトを持つことができるパスもあります。以下が例です。
* EarlyZ のフルパスはさらに多くのドローコールと若干の GPU に対して負荷が増えますが、ベース パスでのピクセル処理を避け、そこでの負荷を大幅に削減することができます。
* HZB を最適化すると、カリングがより控えめになります。
* スクリーンの大部分がシャドウの場合、シャドウを有効化するとライトのライティング負荷を減らすことができます。

## GPU のボトルネックについて

パフォーマンス負荷は、ピクセル数に比例する場合が多いです。**r.SetRes** を使ってレンダリング解像度を変更したり、エディタのビューポートをスケールすれば、試すことができます。
**r.ScreenPercentage** を使うとさらに便利ですが、機能が使用されるとアップサンプリング負荷が追加されることを覚えておいてください。

かなり大きなパフォーマンスの変更があった場合は、ピクセル関連の何かの制約を受けています。通常、メモリ帯域 (読み書き) か演算 (ALU) のいずれかですが、 
特定のユニットがサチュレートしている稀なケースもあります (MRT エクスポートなど)。関連するパスでメモリ (または演算) を下げてパフォーマンスに違いが出れば、それはメモリ帯域の制約を受けていることがわかります (または ALU ユニット)。 
これは単なるテストなので、違いが同じに見える必要はありません。これで、パフォーマンス改善のために減らす必要のある負荷の正体が分かりました。

シャドウマップ解像度はスクリーン解像度 ( **r.Shadow.MaxResolution** を使用) でスケールすることはできませんが、かなり広い領域にマスクされたマテリアル、または透過マテリアルをシャドウキャストしない限り、 
ピクセル シェーダーの制約は受けません。シャドウマップ レンダリングは、頂点処理あるいはトライアングル化 (高密度のメッシュ、 LOD なし、テセレーション、 WorldPositionOffset の使用) の制約を受ける場合が多いです。 
シャドウマップ レンダリングは、ライト数、カスケード / キューブマップの側面、ライト錐台でシャドウキャスティングしているオブジェクト数に比例します。これはよくあるボトルネックで、 
負荷を減らす方法は大きいコンテンツを変更するのみです。

ワイヤーフレームがソリッドなカラーで表示される場合、クワッドを使用しないと細分化が進んだメッシュに支障ができます。これは、
 GPU がトライアングルを 2x2 ピクセルブロックに処理し、トライアングルの外のピクセルを少し後で拒否するためです。これは、ミップマップの演算処理に必要です。大きめのトライアングルでは特に問題になりませんが、
 トライアングルが小さかったり冗長な場合、かなりの数のピクセルが処理されるのに実際にはほとんど画像に影響しないため、パフォーマンスが下がります。ライティングで非常にうまくクワッドを使用しているので、ディファード・シェーディングがこの状況を改善します。
問題はベース パスに残るので、複雑なマテリアルのレンダリングはかなり遅くなります。
これを解決するには、密度の低いメッシュを使用します。詳細度メッシュで、問題がある場合のみ行うことができます。

[REGION:note]
**r.EarlyZPass** を調整して、フルの Early Z パスをシーンにうまく使えているかどうかを確認します (ベース パス中にドローコールが増加しオーバードローは減少)。
[/REGION]

解像度を変更しても関係ない場合、頂点処理 (バーテックス シェーダー、テセレーション) 負荷の制約を受けている可能性が高いです。
それを確認するためには、コンテンツを変更する必要のある場合が多いです。以下はよくあるケースです。

* 頂点が多すぎる (詳細度メッシュを使用)
* ミップマップが弱いテクスチャを使った複雑な WorldPositionOffset / Displacement マテリアル
* テセレーション (可能な限り避けてください。最速の方法 **show Tessellation** でテセレーション係数を調整します。ハードウェアによっては、テセレーション レベルが粗いとうまくスケールできないものもあります。
* UV あるいは法線シームは頂点が増える場合が多いです (アンラップされた UV を見ると UV 島はほとんど失敗で、フラット化されたメッシュはトライアングルごとに頂点が 3 つあります)。
* 頂点属性が多すぎる (余分な UV チャネル)
* 頂点数が適切か確認する。インポータ コードには頂点を結合 (同じ位置、 UV 、法線を持つ頂点をまとめる) しないものもある。


それほど頻繁ではありませんが、何かの制約を受けることがあります。例えば以下のものです。
* オブジェクトの負荷 (CPU 負荷の場合が多いが、 GPU 負荷も若干含まれる)
* トライアングル設定負荷 (シャドウマップ スタティックメッシュなどの、負荷が小さいバーテックス シェーダーでポリゴン数の多いメッシュはほとんど問題にはなりません)
  * 詳細度 (LOD) メッシュを使う
* 表示負荷 (HZB オクルージョン カリングなど)
* シーン負荷 (GPU パーティクル シミュレーションなど)

