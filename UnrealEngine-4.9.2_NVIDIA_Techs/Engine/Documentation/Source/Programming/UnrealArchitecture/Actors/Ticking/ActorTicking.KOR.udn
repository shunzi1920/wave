INTSourceChangelist:2621752
Availability: Docs
Title:액터 틱
Crumbs:%ROOT%, Programming
Description:매 프레임 액터를 업데이트하는 데 사용되는 Tick, 틱 시스템에 대한 설명입니다.
Version: 4.9

[TOC (start:2 end:3)]

액터는 월드의 액터 리스트(모든 레벨의 리스트 총합)에 나타나는 순서대로, 프레임 사이 경과 시간으로 프레임마다 한 번씩 틱이 적용됩니다. 현재 액터의 틱은 3 단계로 이루어지는데: 
비동기 작업 전, 비동기 작업 중, 비동기 작업 후 입니다. 액터의 틱이 어느 그룹에서 일어나는지는 TickGroup 멤버로 제어합니다. 상태 업데이트를 비동기 작업 전 (피직스 등은 나중에) 해야 하는 액터는 
TG_PreAsyncWork 그룹에 할당시켜 줘야 합니다. 그렇게 하지 못하는 경우, 잘못된 동작 및/또는 한 프레임 어긋나는 문제가 생깁니다.
피직스를 비롯한 기타 스레드와 병행해서 틱을 해도 되는 액터는 TG_DuringAsyncWork 그룹에 할당됩니다. 그 그룹의 액터가 리짓 바디 피직스 데이터에 닿는 경우,
오류가 기록되고 호출은 무시됩니다. 이는 메모리 누수, 유효하지 않은 씬 상태 등으로 이어질 수 있으니 부지런하게 수정해 줘야 합니다. SpawnActor(), MoveActor(), SetLocation(), SetCollision() 등에도 
마찬가지입니다. 이 함수들은 실행은 계속되지만, 피직스 스레드에는 영향을 끼치지 않으며, 로그에도 오류로 남습니다. 마지막으로 피직스 업데이트에 의존하는 액터는 그룹을 
TG_PostAsyncWork 로 설정합니다. 이 그룹의 액터는 정확한 월드 상태를 나타내기 위해 물리 시뮬레이션 결과에 의존하는 것들입니다 (비히클, 래그돌 등). 이 단계에서의 무브먼트, 스폰, 콜리전에 대한 함수는 
언리얼과 피직스 둘 다 호출해 주는 것이 안전합니다.


액터를 각 틱 그룹에 넣었을 때의 장단점은 이렇습니다:



### TG_PreAsyncGroup

+ 언리얼 함수는 노보덱스 피직스 함수든 안전하게 호출할 수 있습니다.

+ 물리 시뮬레이션에 대한 위치, 방향 등을 업데이트합니다.

- 마지막 프레임의 물리 시뮬레이션 결과에 작동합니다.

- 병렬 처리되지 않습니다.



### TG_DuringAsyncGroup

+ 물리 시뮬레이션과 병행 처리됩니다.

- 특정 언리얼 함수와 씬 데이터에 (읽기 제외) 쓰기를 하는 노보덱스 피직스 함수는 전부 호출하기에 안전하지 않습니다.



### TG_PostAsyncGroup

+ 언리얼 함수든 노보덱스 피직스 함수는 안전하게 호출할 수 있습니다.

+ 현재 프레임의 물리 시뮬레이션 데이터에 작동합니다.

- 병렬 처리되지 않습니다.

액터를 어느 한 리스트에 넣을 때의 일반적인 규칙이라면:

1. 콜리전을 바꾸거나, 충돌가능 액터를 스폰하거나, 노보덱스 데이터에 쓰기를 하면 TG_PreAsyncWork 입니다. 보통 여기에 들어가는 것은 Pawn, Weapon, 일부 리짓 바디 클래스 입니다.
1. 콜리전을 바꾸지 않거나, 충돌하는 액터를 스폰하지 않거나 (non-colliding 이면 괜찮습니다), 노보덱스 데이터를 변경하지 않는 액터는 TG_DuringAsyncWork 그룹에 넣어야 합니다. 그런 액터는 여기에 넣는 것이 가장 좋은데, 액터 틱에 시간이 소모되는 만큼 물리 시뮬레이션에 소모되는 시간을 숨겨주기 때문에, 즉 이곳의 틱 시간이 2ms 라는 것은 2ms 까지의 시뮬레이션 시간은 공짜라는 뜻이기 때문입니다. 이 그룹에 좋은 후보는 파티클 시스템, 오디오, AI 처리 입니다.
1. 노보덱스에서 데이터를 반환받아야 언리얼 데이터를 업데이트할 수 있는 액터라면 TG_PostAsyncWork 에 들어가야 합니다. 보통 비히클과 래그돌이 여기에 들어갑니다.



## 액터 스폰

액터를 스폰한다는 것은, 액터(와 그 모든 컴포넌트)의 틱 그룹에 상관없이 스폰된 그룹에서 틱이 적용된다는 뜻입니다. 바로 다음 프레임, 새로 스폰된 액터는 올바른 틱 그룹에서 틱이 적용됩니다. 
여기에 한 가지 예외는, 비동기 작업 도중 스폰된 액터는 TG_PostAsyncWork 까지 미뤄지게(defer) 됩니다.



## 컴포넌트 틱

액터를 각기 다른 틱 그룹으로 분리할 수 있듯이, 컴포넌트도 마찬가지입니다. 기존에는, 액터가 틱  도중 그 모든 컴포넌트에 틱을 적용했습니다. 이 부분은 지금도 여전하나, 다른 그룹에서 틱을 적용해야 하는 
컴포넌트는 별도의 틱 시기를 관리하는 리스트에 추가됩니다. 컴포넌트는 액터의 틱 그룹을 나눌 때와 같은 범주로 틱 그룹을 나눕니다.



## 틱 코드 흐름

| **게임 스레드** | **피직스 스레드** |
| --- | --- |
| 월드의 액터 리스트를 살펴 TG_PreAsyncWork 인 것은 틱 적용하고 나머지는 유예시킵니다. | 빈둥 |
| 틱이 적용되는 각 액터에 대해, 컴포넌트 리스트를 살펴 TG_PreAsyncWork 틱 적용하고 나머지는 유예시킵니다. | 빈둥 |
| 피직스 스레드를 시작하라 이릅니다. | 시뮬레이션 시작 |
| TG_DuringAsyncWork 리스트의 각 액터에 대해 틱을 적용합니다. | 물리 시뮬레이션 |
| 액터의 각 컴포넌트에 대해 틱을 적용하고 필요하면 유예시킵니다. | 물리 시뮬레이션 |
| TG_DuringAsycnWork 까지 유예된 각 컴포넌트에 대해 틱을 적용합니다. | 물리 시뮬레이션 |
| 피직스 작업 완료시까지 블록합니다. | 시뮬레이션 결과 반환 |
| TG_PostAsyncWork 리스트의 각 액터에 대해 틱을 적용합니다. | 빈둥 |
| 액터의 각 컴포넌트에 대해, 틱을 적용합니다. | 빈둥 |
| TG_PostAsycnWork 까지 유예된 각 컴포넌트에 대해 틱을 적용합니다. | 빈둥 |
| 렌더링 & 반복 | 빈둥 |



## 자세한 코드 흐름 (틱 이후까지)


### 코드 흐름 (매 프레임)


    
    오브젝트 틱
       물리 전
          콘트롤러 (입력)
          폰 (스크립트)
          컴포넌트
             스켈레탈 메시 컴포넌트: 애니메이션, 스켈레탈 콘트롤 업데이트한 다음 매트릭스 계산
       물리, 비동기
          폰 물리
       물리 후
       카메라 틱
       뷰포트 틱
    
       "서버 트래블링"
       "클라이언트 트래블링"
       스트리밍
    
    렌더링
       VP 매트릭스 계산 (스크립트로 카메라에 묻고, 캐시된 값 반환)
       Controller.PreRender
          UTPawn.PreRender (라이선시가 사용하기도 정말 좋음)
       모두 렌더링
    
    오디오
    
    콜그래프 계산
    




### 중요한 이유

틱 및 렌더링 순서를 이해하는 것은 1 프레임 어긋나는 문제를 피하고 호출 순서의 종속성 문제를 우회하기 위해 필수입니다. 예를 들어 카메라는 모든 틱 완료 이후 업데이트되므로, 
카메라에 관련된 (일인칭 부착물 또는 레이저 조준점같은) 것은 PreRender 에서 이루어져야 합니다. 그러나 예를 들어 카메라 위치에 따른 애니메이션 종속성이 있는 경우 
1 프레임 어긋나는 **문제가 발생** 할 것입니다. 왜냐하면 애니메이션은 물리 전에 일어나고, 폰 이동은 물리 도중 일어나고, 카메라는 (전형적으로) 폰 위치에 종속되어 있기에, 
애니메이션 종속성에 순환 고리가 형성되기 떄문입니다. 이러한 문제를 회피하려면, 프레임당 한 번 이상 계산해 주는 방식이 필요할 수 있습니다. 
카메라 틱도 애니메이션 틱도 물리 이후로 이동하면 애니메이션에 올바른 카메라 위치 업데이트가 가능할 것입니다 (하지만 별도로 코딩을 해 주지 않는 이상 카메라는 프레임당 두 번 업데이트될 것입니다).

 - Jordan Weitz

 




