// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	BasePassForForwardShadingVertexShader.usf: Base pass vertex shader used with forward shading
=============================================================================*/

#define IS_FORWARD_BASEPASS_VERTEX_SHADER 1

// @todo urban: branch was: #define FORCE_FLOATS 1
#define FORCE_FLOATS METAL_PROFILE

#include "Common.usf"
#include "BasePassForForwardShadingCommon.usf"
#include "Material.usf"
#include "VertexFactory.usf"
#include "HeightFogCommon.usf"

struct FForwardShadingBasePassVSToPS
{
	FVertexFactoryInterpolantsVSToPS FactoryInterpolants;
	FForwardShadingBasePassInterpolantsVSToPS BasePassInterpolants;
	float4 Position : SV_POSITION;
};

// NVCHANGE_BEGIN: Add VXGI
#if VXGI_VOXELIZATION_SHADER

#if USING_TESSELLATION	

	struct FForwardShadingBasePassVSToDS
	{
		FVertexFactoryInterpolantsVSToDS FactoryInterpolants;
		FForwardShadingBasePassInterpolantsVSToPS BasePassInterpolants; //These are the same
		float4 Position : VS_To_DS_Position;
		OPTIONAL_VertexID_VS_To_DS
	};
	
	#define FForwardShadingBasePassVSOutput FForwardShadingBasePassVSToDS
	#define VertexFactoryGetInterpolants VertexFactoryGetInterpolantsVSToDS
	#define FPassSpecificVSToDS FForwardShadingBasePassVSToDS
	#define FPassSpecificVSToPS FForwardShadingBasePassVSToPS

	
	FForwardShadingBasePassVSToDS PassInterpolate(FForwardShadingBasePassVSToDS a, float aInterp, FForwardShadingBasePassVSToDS b, float bInterp)
	{
		FForwardShadingBasePassVSToDS O;
	
		O.FactoryInterpolants = VertexFactoryInterpolate(a.FactoryInterpolants, aInterp, b.FactoryInterpolants, bInterp);

		#if NEEDS_BASEPASS_FOGGING
			TESSELLATION_INTERPOLATE_MEMBER(BasePassInterpolants.VertexFog);
		#endif

		#if USE_WORLD_POSITION_EXCLUDING_SHADER_OFFSETS
			TESSELLATION_INTERPOLATE_MEMBER(BasePassInterpolants.WorldPositionExcludingWPO);
		#endif

		return O;
	}

	FForwardShadingBasePassVSToPS PassFinalizeTessellationOutput(FForwardShadingBasePassVSToDS Interpolants, float4 WorldPosition, FMaterialTessellationParameters MaterialParameters)
	{
		FForwardShadingBasePassVSToPS O;
	
		O.FactoryInterpolants = VertexFactoryAssignInterpolants(Interpolants.FactoryInterpolants);

		// Copy everything in the shared base class over to the pixel shader input
		(FForwardShadingBasePassInterpolantsVSToPS)O.BasePassInterpolants = (FForwardShadingBasePassInterpolantsVSToPS)Interpolants.BasePassInterpolants;

		// Transform position to clip-space
		ISOLATE
		{
			O.Position = mul(WorldPosition, View.TranslatedWorldToClip);
		}
	
		// Calc position-dependent interps
		O.BasePassInterpolants.PixelPosition = WorldPosition;

		#if USE_WORLD_POSITION_EXCLUDING_SHADER_OFFSETS
			O.BasePassInterpolants.PixelPositionExcludingWPO = float4(Interpolants.BasePassInterpolants.WorldPositionExcludingWPO, 1);
		#endif

		return O;
	}

	// This gets us the MainHull and MainDomain shader definitions
	#include "Tessellation.usf"

#else
	#define FForwardShadingBasePassVSOutput FForwardShadingBasePassVSToPS
	#define VertexFactoryGetInterpolants VertexFactoryGetInterpolantsVSToPS
#endif


#else
// NVCHANGE_END: Add VXGI

#define FForwardShadingBasePassVSOutput FForwardShadingBasePassVSToPS
#define VertexFactoryGetInterpolants VertexFactoryGetInterpolantsVSToPS

// NVCHANGE_BEGIN: Add VXGI
#endif
// NVCHANGE_END: Add VXGI

/** Entry point for the base pass vertex shader. */
void Main(
	FVertexFactoryInput Input,
	out FForwardShadingBasePassVSOutput Output
	)
{
#if PACK_INTERPOLANTS
	float4 PackedInterps[NUM_VF_PACKED_INTERPOLANTS];
	UNROLL 
	for(int i = 0; i < NUM_VF_PACKED_INTERPOLANTS; ++i)
	{
		PackedInterps[i] = 0;
	}
#endif

	FVertexFactoryIntermediates VFIntermediates = GetVertexFactoryIntermediates(Input);
	float4 WorldPositionExcludingWPO = VertexFactoryGetWorldPosition(Input, VFIntermediates);
	float4 WorldPosition = WorldPositionExcludingWPO;

	half3x3 TangentToLocal = VertexFactoryGetTangentToLocal(Input, VFIntermediates);	
	FMaterialVertexParameters VertexParameters = GetMaterialVertexParameters(Input, VFIntermediates, WorldPosition.xyz, TangentToLocal);

	half3 WorldPositionOffset = GetMaterialWorldPositionOffset(VertexParameters);
	
	WorldPosition.xyz += WorldPositionOffset;

// NVCHANGE_BEGIN: Add VXGI
#if VXGI_VOXELIZATION_SHADER && USING_TESSELLATION
	// We let the Domain Shader convert to post projection when tessellating
	Output.Position = WorldPosition;	
	Output.BasePassInterpolants.PixelPosition = WorldPosition;

	#if USE_WORLD_POSITION_EXCLUDING_SHADER_OFFSETS
		Output.BasePassInterpolants.WorldPositionExcludingWPO = WorldPositionExcludingWPO;
	#endif
#else
// NVCHANGE_END: Add VXGI

	float4 RasterizedWorldPosition = VertexFactoryGetRasterizedWorldPosition(Input, VFIntermediates, WorldPosition);
	Output.Position = mul(RasterizedWorldPosition, View.TranslatedWorldToClip);
	Output.BasePassInterpolants.PixelPosition = WorldPosition;

#if USE_WORLD_POSITION_EXCLUDING_SHADER_OFFSETS
	Output.BasePassInterpolants.PixelPositionExcludingWPO = WorldPositionExcludingWPO;
#endif

// NVCHANGE_BEGIN: Add VXGI
#endif
// NVCHANGE_END: Add VXGI

#if USE_VERTEX_FOG
#if PACK_INTERPOLANTS
	PackedInterps[0] = CalculateVertexHeightFog(WorldPosition.xyz, View.TranslatedViewOrigin);
#else
	Output.BasePassInterpolants.VertexFog = CalculateVertexHeightFog(WorldPosition.xyz, View.TranslatedViewOrigin);
#endif // PACK_INTERPOLANTS
#endif

#if LANDSCAPE_BUG_WORKAROUND
	Output.BasePassInterpolants.DummyInterp = 0;
#endif

	Output.FactoryInterpolants = VertexFactoryGetInterpolants(Input, VFIntermediates, VertexParameters);

	Output.BasePassInterpolants.PixelPosition.w = Output.Position.w;

#if PACK_INTERPOLANTS
	VertexFactoryPackInterpolants(Output.FactoryInterpolants, PackedInterps);
#endif // PACK_INTERPOLANTS

#if OUTPUT_GAMMA_SPACE && COMPILER_GLSL_ES2
	Output.Position.y *= -1;
#endif
}
