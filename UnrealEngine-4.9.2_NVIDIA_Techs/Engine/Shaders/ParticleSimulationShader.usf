// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

/*==============================================================================
	ParticleSimulationShader.usf: Shaders for simulating particles on the GPU.
==============================================================================*/

#include "Common.usf"

#if DISTANCE_FIELD_COLLISION
	#include "GlobalDistanceFieldShared.usf"
#endif

/*------------------------------------------------------------------------------
	Shared declarations and functions.
------------------------------------------------------------------------------*/

struct FShaderInterpolants
{
	/** The texture coordinate at which to sample. */
	float2 TexCoord : TEXCOORD0;
};

/*------------------------------------------------------------------------------
	Vertex shader.

	Compile time parameters:
		TILE_SIZE_X - The width of a particle tile in the texture.
		TILE_SIZE_Y - The height of a particle tile in the texture.
------------------------------------------------------------------------------*/
#if VERTEXSHADER

struct FVertexInput
{
	/** Unique vertex ID. */
	uint VertexId	: SV_VertexID;
	/** Unique instance ID. */
	uint InstanceId	: SV_InstanceID;
	/** The texture coordinate. */
	float2 TexCoord	: ATTRIBUTE0;
};

/** Buffer from which to read tile offsets. */
Buffer<float2> TileOffsets;

void VertexMain(
	in FVertexInput Input,
	out FShaderInterpolants Interpolants,
	out float4 OutPosition : SV_POSITION
	)
{
	uint InstanceId = Input.InstanceId * TILES_PER_INSTANCE + Input.VertexId / 4;
	
float2 TileCoord = Input.TexCoord.xy * float2(TILE_SIZE_X,TILE_SIZE_Y) + TileOffsets[InstanceId];

	OutPosition = float4(
		TileCoord.xy * float2(2.0f,-2.0f) + float2(-1.0f,1.0f),
		0,
		1
		);
	Interpolants.TexCoord.xy = TileCoord.xy;
}

#endif // #if VERTEXSHADER

/*------------------------------------------------------------------------------
	Particle simulation pixel shader.
------------------------------------------------------------------------------*/
#if PARTICLE_SIMULATION_PIXELSHADER

/** Define to 1 to force no collision in the shader. */
#define FORCE_NO_COLLISION 0

#if FORCE_NO_COLLISION
	#undef DEPTH_BUFFER_COLLISION
	#define DEPTH_BUFFER_COLLISION 0
	#undef DISTANCE_FIELD_COLLISION
	#define DISTANCE_FIELD_COLLISION 0
#endif

/** Position (XYZ) and squared radius (W) of the point attractor. */
float4 PointAttractor;
/** Position offset (XYZ) to add to particles and strength of the attractor (W). */
float4 PositionOffsetAndAttractorStrength;
/** Amount by which to scale bounds for collision purposes. */
float2 LocalToWorldScale;
/** Amount of time by which to simulate particles. */
float DeltaSeconds;

// NVCHANGE_BEGIN: JCAO - Support Force Type Noise
float TotalSeconds;
// NVCHANGE_END: JCAO - Support Force Type Noise

/** Texture from which to read particle position. */
Texture2D PositionTexture;
SamplerState PositionTextureSampler;

/** Texture from which to read particle velocity. */
Texture2D VelocityTexture;
SamplerState VelocityTextureSampler;
/** Texture from which to read particle attributes. */
Texture2D AttributesTexture;
SamplerState AttributesTextureSampler;
/** Texture from which curves can be sampled. */
Texture2D CurveTexture;
SamplerState CurveTextureSampler;

/** Textures from which to sample vector forces. */
#if MAX_VECTOR_FIELDS != 4
#error This must match MAX_VECTOR_FIELDS in C++ land
#endif
Texture3D VectorFieldTextures0;
Texture3D VectorFieldTextures1;
Texture3D VectorFieldTextures2;
Texture3D VectorFieldTextures3;
SamplerState VectorFieldTexturesSampler0;
SamplerState VectorFieldTexturesSampler1;
SamplerState VectorFieldTexturesSampler2;
SamplerState VectorFieldTexturesSampler3;

/**
 * Computes the orbit velocity to apply to the particle based on time.
 * @param Time - The time at which to evaluate the velocity.
 * @param RandomOrbit - Random value used to add variation to orbit.
 */
float3 ComputeOrbitVelocity(float Time, float RandomOrbit)
{
	float3 Sines, Cosines;

	// Read parameters.
	const float3 Offset = Simulation.OrbitOffsetBase.xyz + Simulation.OrbitOffsetRange.xyz * RandomOrbit;
	const float3 Frequency = Simulation.OrbitFrequencyBase.xyz + Simulation.OrbitFrequencyRange.xyz * RandomOrbit;
	const float3 Phase = Simulation.OrbitPhaseBase.xyz + Simulation.OrbitPhaseRange.xyz * RandomOrbit;

	// Compute angles along with cos + sin of those angles.
	const float3 Angles = Frequency.xyz * Time.xxx + Phase.xyz;
	sincos(Angles, Sines, Cosines);

	// Compute velocity required to follow orbit path.
	return Offset.xyz * (Frequency.zxy * Cosines.zxy - Frequency.yzx * Sines.yzx);
}

/**
 * While the VectorFieldTextures array is split into flat textures, we need a way to 
 * sample a texture by index, this function wraps 
 * 
 * 	// @todo compat hack - remove this function
 */
 float3 SampleVectorFieldTexture(int Index, float3 UV)
 {
	if (Index == 0) return Texture3DSample(VectorFieldTextures0, VectorFieldTexturesSampler0, UV).xyz;
	if (Index == 1) return Texture3DSample(VectorFieldTextures1, VectorFieldTexturesSampler1, UV).xyz;
	if (Index == 2) return Texture3DSample(VectorFieldTextures2, VectorFieldTexturesSampler2, UV).xyz;
	return Texture3DSample(VectorFieldTextures3, VectorFieldTexturesSampler3, UV).xyz;
 }

 // NVCHANGE_BEGIN: JCAO - Replace vector fields with APEX turbulence velocity fields
#if WITH_APEX_TURBULENCE
// NVCHANGE_BEGIN: JCAO - Add Attractor working with GPU particles
void EvaluateAttractorFS(out float4 OutVelocity, float3 Position)
{
	float3 WeightedVelocity = 0;
	float Weight = 0;

	if (AttractorFieldSamplers.Count > 0)
	{
		float3 DirectionToPoint = AttractorFieldSamplers.Origin - Position;
		const float3 RadiusAndStrength = AttractorFieldSamplers.RadiusAndStrength;
		const float Radius = RadiusAndStrength.x;
		const float ConstFieldStrength = RadiusAndStrength.y;
		const float VariableFieldStrength = RadiusAndStrength.z;

		float Distance = length(DirectionToPoint) / Radius;

		float Result = ConstFieldStrength;
		if (Distance >= 0.4f)
		{
			Result += VariableFieldStrength / Distance;
		}
		
		WeightedVelocity = Result * normalize(DirectionToPoint);
		Weight = saturate((1.0f - Distance) / 0.00001f);
	}

	OutVelocity.xyz = WeightedVelocity;
	OutVelocity.w = Weight;
}
// NVCHANGE_END: JCAO - Add Attractor working with GPU particles
/**
* Compute the influence of velocity field on a particle at the given position.
 */
void EvaluateVelocityFields(out float4 OutVelocity, float3 Position, float PerParticleScale)
{
	float3 WeightedVelocity = 0;
	float TotalWeight = 0;
	float FinalWeight = 0;

	for (int VectorFieldIndex = VectorFields.VectorFieldCount; VectorFieldIndex < (VectorFields.VectorFieldCount + VectorFields.VelocityFieldCount); ++VectorFieldIndex)
	{
		const float2 IntensityAndTightness = VectorFields.IntensityAndTightness[VectorFieldIndex];
		const float Multiplier = IntensityAndTightness.x;
		const float Weight = IntensityAndTightness.y;
		const float3 VolumeSize = VectorFields.VolumeSize[VectorFieldIndex];
		float3 VolumeUV = mul(float4(Position.xyz,1), VectorFields.WorldToVolume[VectorFieldIndex]).xyz;

		const float3 AxisWeights = 
			saturate(VolumeUV * VolumeSize.xyz) *
			saturate((1.0f - VolumeUV) * VolumeSize.xyz);
		const float DistanceWeight = min(AxisWeights.x, min(AxisWeights.y, AxisWeights.z));

		const float3 VectorSample = SampleVectorFieldTexture(VectorFieldIndex, saturate(VolumeUV));
		WeightedVelocity += (VectorSample * Multiplier * DistanceWeight * Weight);
		TotalWeight += (DistanceWeight * Weight);
		FinalWeight = max(FinalWeight, DistanceWeight * Weight);
	}

	OutVelocity.xyz = WeightedVelocity / (TotalWeight + 0.001f);
	OutVelocity.w = FinalWeight;
}

// NVCHANGE_BEGIN: JCAO - Support Force Type Noise
static const int X_NOISE_GEN = 1619;
static const int Y_NOISE_GEN = 31337;
static const int Z_NOISE_GEN = 6971;
static const int W_NOISE_GEN = 1999;
static const int SEED_NOISE_GEN = 1013;
static const int SHIFT_NOISE_GEN = 8;

int Fastfloor(float x)
{
	return (x >= 0) ? (int)x : (int)(x - 1);
}

// 4D simplex noise
// returns: (x,y,z) = noise grad, w = noise value
float4 Eval4D(float x, float y, float z, float w, int seed)
{
	// The skewing and unskewing factors are hairy again for the 4D case
	float sq = sqrt(5.0f);
	const float F4 = (sq - 1.0f) / 4.0f;
	const float G4 = (5.0f - sq) / 20.0f;
	// Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in
	float s = (x + y + z + w) * F4; // Factor for 4D skewing
	int ix = Fastfloor(x + s);
	int iy = Fastfloor(y + s);
	int iz = Fastfloor(z + s);
	int iw = Fastfloor(w + s);
	float t = (ix + iy + iz + iw) * G4; // Factor for 4D unskewing
	// Unskew the cell origin back to (x,y,z,w) space
	float x0 = x - (ix - t); // The x,y,z,w distances from the cell origin
	float y0 = y - (iy - t);
	float z0 = z - (iz - t);
	float w0 = w - (iw - t);

	int c  = (x0 > y0) ? (1 << 0) : (1 << 2);
	c += (x0 > z0) ? (1 << 0) : (1 << 4);
	c += (x0 > w0) ? (1 << 0) : (1 << 6);
	c += (y0 > z0) ? (1 << 2) : (1 << 4);
	c += (y0 > w0) ? (1 << 2) : (1 << 6);
	c += (z0 > w0) ? (1 << 4) : (1 << 6);

	float4 res = 0;

	// Calculate the contribution from the five corners
	for (int p = 4; p >= 0; --p)
	{
		int ixp = ((c >> 0) & 3) >= p ? 1 : 0;
		int iyp = ((c >> 2) & 3) >= p ? 1 : 0;
		int izp = ((c >> 4) & 3) >= p ? 1 : 0;
		int iwp = ((c >> 6) & 3) >= p ? 1 : 0;

		float xp = x0 - ixp + (4 - p) * G4;
		float yp = y0 - iyp + (4 - p) * G4;
		float zp = z0 - izp + (4 - p) * G4;
		float wp = w0 - iwp + (4 - p) * G4;

		float t = 0.6f - xp * xp - yp * yp - zp * zp - wp * wp;
		if (t > 0)
		{
			//get index
			int gradIndex = (
				                X_NOISE_GEN    * (ix + ixp)
				                + Y_NOISE_GEN    * (iy + iyp)
				                + Z_NOISE_GEN    * (iz + izp)
				                + W_NOISE_GEN    * (iw + iwp)
				                + SEED_NOISE_GEN * seed)
				            & 0xffffffff;
			gradIndex ^= (gradIndex >> SHIFT_NOISE_GEN);
			gradIndex &= 31;

			float4 g;
			{
				const int h = gradIndex;
				const int hs = 2 - (h >> 4);
				const int h1 = (h >> 3);
				g.x = (h1 == 0) ? 0.0f : ((h & 4)       ? -1.0f : 1.0f);
				g.y = (h1 == 1) ? 0.0f : ((h & (hs << 1)) ? -1.0f : 1.0f);
				g.z = (h1 == 2) ? 0.0f : ((h & hs)      ? -1.0f : 1.0f);
				g.w = (h1 == 3) ? 0.0f : ((h &  1)      ? -1.0f : 1.0f);
			}
			float gdot = (g.x * xp + g.y * yp + g.z * zp + g.w * wp);

			float t2 = t * t;
			float t3 = t2 * t;
			float t4 = t3 * t;

			float dt4gdot = 8 * t3 * gdot;

			res.x += t4 * g.x - dt4gdot * xp;
			res.y += t4 * g.y - dt4gdot * yp;
			res.z += t4 * g.z - dt4gdot * zp;
			res.w += t4 * gdot;
		}
	}
	// scale the result to cover the range [-1,1]
	res *= 27;
	return res;
}

void EvaluateNoiseFS(out float3 OutForce, float3 Position)
{
	float3 Force = 0;
	if (NoiseFieldSamplers.Count > 0)
	{
		float NoiseStrength = NoiseFieldSamplers.NoiseStrengthAndTimeFreq.x;
		float Time = NoiseFieldSamplers.NoiseStrengthAndTimeFreq.y * TotalSeconds;
		float NoiseStrengthOctaveMultiplier = NoiseFieldSamplers.NoiseStrengthAndTimeFreq.z;
		float NoiseTimeFreqOctaveMultiplier = NoiseFieldSamplers.NoiseStrengthAndTimeFreq.w;

		float3 Point = float3(NoiseFieldSamplers.NoiseSpaceFreq.x * Position.x, NoiseFieldSamplers.NoiseSpaceFreq.y * Position.y, NoiseFieldSamplers.NoiseSpaceFreq.z * Position.z);
		float Amp = 1.0f;
		int Seed = NoiseFieldSamplers.NoiseSeed;

		if (NoiseFieldSamplers.NoiseType == 1)
		{
			float4 dFx = 0;
			float4 dFy = 0;
			float4 dFz = 0;
			for (int i = 0; i < NoiseFieldSamplers.NoiseOctaves; ++i)
			{
				dFx += Amp * Eval4D(Point.x, Point.y, Point.z, Time, ++Seed);
				dFy += Amp * Eval4D(Point.x, Point.y, Point.z, Time, ++Seed);
				dFz += Amp * Eval4D(Point.x, Point.y, Point.z, Time, ++Seed);

				Amp *= NoiseStrengthOctaveMultiplier;
				Point.x *= NoiseFieldSamplers.NoiseSpaceFreqOctaveMultiplier.x;
				Point.y *= NoiseFieldSamplers.NoiseSpaceFreqOctaveMultiplier.y;
				Point.z *= NoiseFieldSamplers.NoiseSpaceFreqOctaveMultiplier.z;
				Time *= NoiseTimeFreqOctaveMultiplier;
			}
			//build curl noise as a result
			Force.x = dFz.y - dFy.z;
			Force.y = dFx.z - dFz.x;
			Force.z = dFy.x - dFx.y;
		}
		else
		{
			float4 noise = 0;
			for (int i = 0; i < NoiseFieldSamplers.NoiseOctaves; ++i)
			{
				noise += Amp * Eval4D(Point.x, Point.y, Point.z, Time, ++Seed);

				Amp *= NoiseStrengthOctaveMultiplier;
				Point.x *= NoiseFieldSamplers.NoiseSpaceFreqOctaveMultiplier.x;
				Point.y *= NoiseFieldSamplers.NoiseSpaceFreqOctaveMultiplier.y;
				Point.z *= NoiseFieldSamplers.NoiseSpaceFreqOctaveMultiplier.z;
				Time *= NoiseTimeFreqOctaveMultiplier;
			}
			//get noise gradient as a result
			Force = noise.xyz;
		}

		Force *= NoiseStrength;
	}
	OutForce = Force;
}
// NVCHANGE_END: JCAO - Support Force Type Noise
#endif
 // NVCHANGE_END: JCAO - Replace vector fields with APEX turbulence velocity fields

/**
 * Compute the influence of vector fields on a particle at the given position.
 * @param OutForce - Force to apply to the particle.
 * @param OutVelocity - Direct velocity influence on the particle.
 * @param Position - Position of the particle.
 * @param PerParticleScale - Amount by which to scale the influence on this particle.
 */
void EvaluateVectorFields(out float3 OutForce, out float4 OutVelocity, float3 Position, float PerParticleScale)
{
	float3 TotalForce = 0;
	float3 WeightedVelocity = 0;
	float TotalWeight = 0;
	float FinalWeight = 0;

	// NVCHANGE_BEGIN: JCAO - Replace vector fields with APEX turbulence velocity fields
	for (int VectorFieldIndex = 0; VectorFieldIndex < VectorFields.VectorFieldCount; ++VectorFieldIndex)
	// NVCHANGE_END: JCAO - Replace vector fields with APEX turbulence velocity fields
	{
		float2 IntensityAndTightness = VectorFields.IntensityAndTightness[VectorFieldIndex];
		float Intensity = IntensityAndTightness.x * PerParticleScale;
		float Tightness = IntensityAndTightness.y;
		float3 VolumeSize = VectorFields.VolumeSize[VectorFieldIndex];
		float3 VolumeUV = mul(float4(Position.xyz,1), VectorFields.WorldToVolume[VectorFieldIndex]).xyz;
		//Tile the UVs if needed. TilingAxes will be 1.0 or 0.0 in each channel depending on which axes are being tiled, if any.
		VolumeUV -= floor(VolumeUV * VectorFields.TilingAxes[VectorFieldIndex].xyz);

		float3 AxisWeights = 
			saturate(VolumeUV * VolumeSize.xyz) *
			saturate((1.0f - VolumeUV) * VolumeSize.xyz);
		float DistanceWeight = min(AxisWeights.x, min(AxisWeights.y, AxisWeights.z));

		// @todo compat hack: Some compilers only allow constant indexing into a texture array
//		float3 VectorSample = Texture3DSample(VectorFieldTextures[VectorFieldIndex], VectorFieldTexturesSampler, saturate(VolumeUV)).xyz;
float3 VectorSample = SampleVectorFieldTexture(VectorFieldIndex, saturate(VolumeUV));

		float3 Vec = mul(float4(VectorSample,0), VectorFields.VolumeToWorld[VectorFieldIndex]).xyz;
		TotalForce += (Vec * DistanceWeight * Intensity);
		WeightedVelocity += (Vec * Intensity * DistanceWeight * Tightness);
		TotalWeight += (DistanceWeight * Tightness);
		FinalWeight = max(FinalWeight, DistanceWeight * Tightness);
	}

	// Forces are additive.
	OutForce = TotalForce;
	// Velocities use a weighted average.
	OutVelocity.xyz = WeightedVelocity / (TotalWeight + 0.001f);
	OutVelocity.w = FinalWeight;
}

/**
 * Compute the force due to drag.
 * @param Velocity - Velocity of the particle.
 * @param DragCoefficient - Coefficient of drag to apply to the particle.
 */
float3 ComputeDrag(float3 Velocity, float DragCoefficient)
{
	return -DragCoefficient * Velocity;
}

/**
 * Compute the force on the particle due to a point of attraction.
 * @param Position - The position of the particle.
 */
float3 ComputeAttractionForce(float3 Position)
{
	float3 PointLoc = PointAttractor.xyz;
	float RadiusSq = PointAttractor.w;
	float Strength = PositionOffsetAndAttractorStrength.w;

	float3 DirectionToPoint = PointLoc - Position + float3(0, 0, 0.0001f);
	float DistSq = max(dot(DirectionToPoint,DirectionToPoint), RadiusSq);
	float Attraction = Strength / DistSq;
	return Attraction * normalize(DirectionToPoint);
}

/** For retrieving the size of a particle. */
Texture2D RenderAttributesTexture;
SamplerState RenderAttributesTextureSampler;

#if DEPTH_BUFFER_COLLISION
/** For retrieving the world-space normal. */
Texture2D GBufferATexture;
SamplerState GBufferATextureSampler;

/** Limits the depth bounds for which to search for a collision plane. */
float CollisionDepthBounds;

/**
 * Compute collision with the depth buffer.
 */
void CollideWithDepthBuffer(
	out float3 NewPosition,
	out float3 NewVelocity,
	inout float RelativeTime,
	in float3 InPosition,
	in float3 InVelocity,
	in float3 Acceleration,
	in float CollisionRadius,
	in float Resilience
	)
{
	// Integration assuming no collision.
	float3 MidVelocity = InVelocity.xyz + 0.5f * Acceleration;
	float3 DeltaPosition = DeltaSeconds * MidVelocity;
	NewPosition = InPosition.xyz + DeltaPosition;
	NewVelocity = InVelocity.xyz + Acceleration;

	// Figure out where to sample the depth buffer.
	float3 CollisionOffset = normalize(DeltaPosition) * CollisionRadius;
	float3 CollisionPosition = InPosition + CollisionOffset;
	float4 SamplePosition = float4(CollisionPosition + View.PreViewTranslation,1);
	float4 ClipPosition = mul(SamplePosition, View.TranslatedWorldToClip);
	float2 ScreenPosition = ClipPosition.xy / ClipPosition.w;

	// Don't try to collide if the particle falls outside the view.
	if (all(abs(ScreenPosition.xy) <= float2(1,1)))
	{
		// Sample the depth buffer to get a world position near the particle.
		float2 ScreenUV = ScreenPosition * View.ScreenPositionScaleBias.xy + View.ScreenPositionScaleBias.wz;
		float SceneDepth = CalcSceneDepth(ScreenUV);

		if (abs(ClipPosition.w - SceneDepth) < CollisionDepthBounds)
		{
			// Reconstruct world position.
			float4 HomogeneousWorldPosition = mul(float4(ScreenPosition.xy * SceneDepth, SceneDepth, 1), View.ScreenToWorld);
			float3 WorldPosition = HomogeneousWorldPosition.xyz / HomogeneousWorldPosition.w;

			// Sample the normal buffer to create a plane to collide against.
			float4 WorldNormal = Texture2DSampleLevel(GBufferATexture, GBufferATextureSampler, ScreenUV, 0) * float4(2,2,2,1) - float4(1,1,1,0);
			float4 CollisionPlane = float4(WorldNormal.xyz, dot(WorldPosition.xyz,WorldNormal.xyz));

			// Compute the portion of velocity normal to the collision plane.
			float VelocityDot = dot(CollisionPlane.xyz, DeltaPosition.xyz);
			float InvVelocityDot = rcp(VelocityDot + 0.0001f); // Add a small amount to avoid division by zero.

			// Distance to the plane from the center of the particle.
			float DistanceToPlane = dot(CollisionPlane.xyz, InPosition.xyz) - CollisionPlane.w;

			// Find out the time of intersection for both the front and back of the sphere.
			float t_back = -(DistanceToPlane + CollisionRadius) * InvVelocityDot;
			float t_front = -(DistanceToPlane - CollisionRadius) * InvVelocityDot;

			//if (t_back >= 0 && t_front <= 1 && DistanceToPlane >= 0)
			if (step(0, t_back) * step(t_front, 1) * step(0, DistanceToPlane))
			{
				// Separate velocity in to the components perpendicular and tangent to the collision plane.
				float3 PerpVelocity = dot(MidVelocity,CollisionPlane.xyz) * CollisionPlane.xyz;
				float3 TanVelocity = MidVelocity - PerpVelocity;

				// Compute the new velocity accounting for resilience and friction.
				NewVelocity = Simulation.OneMinusFriction * TanVelocity - Resilience * PerpVelocity;

				// If the particle lies approximately on the collision plane, don't jump to the point of collision.
				t_front *= step(VelocityDot,-1);

				// Integrate position taking the collision in to account.
				NewPosition = InPosition + DeltaPosition * t_front + NewVelocity * (1.0f - t_front) * DeltaSeconds;

				// Update the relative time. Usually this does nothing, but if the
				// user has elected to kill the particle upon collision this will do
				// so.
				RelativeTime += Simulation.CollisionTimeBias;
			}
			//else if (t_front > 0 && t_back < 1 && DistanceToPlane < 0)
			else if (step(0, t_front) * step(t_back, 1) * step(DistanceToPlane,0))
			{
				// The particle has collided against a backface, kill it by setting
				// relative time to a value > 1.0.
				RelativeTime = 1.1f;
			}
		}
	}
}
#endif // #if DEPTH_BUFFER_COLLISION

#if DISTANCE_FIELD_COLLISION

/**
 * Compute collision with the global signed distance field
 */
void CollideWithDistanceField(
	out float3 NewPosition,
	out float3 NewVelocity,
	inout float RelativeTime,
	in float3 InPosition,
	in float3 InVelocity,
	in float3 Acceleration,
	in float CollisionRadius,
	in float Resilience
	)
{
	// Integration assuming no collision.
	float3 MidVelocity = InVelocity.xyz + 0.5f * Acceleration;
	float3 DeltaPosition = DeltaSeconds * MidVelocity;
	NewPosition = InPosition.xyz + DeltaPosition;
	NewVelocity = InVelocity.xyz + Acceleration;

	float DistanceToNearestSurface = GetDistanceToNearestSurfaceGlobal(InPosition);
	float MaxCollisionDistance = CollisionRadius + length(DeltaPosition.xyz);

	if (DistanceToNearestSurface < MaxCollisionDistance)
	{
		float3 CollisionWorldNormal = normalize(GetDistanceFieldGradientGlobal(InPosition));
		float3 CollisionWorldPosition = InPosition - CollisionWorldNormal * DistanceToNearestSurface;

		float4 CollisionPlane = float4(CollisionWorldNormal.xyz, dot(CollisionWorldPosition.xyz, CollisionWorldNormal.xyz));

		// Compute the portion of velocity normal to the collision plane.
		float VelocityDot = dot(CollisionPlane.xyz, DeltaPosition.xyz);
		float InvVelocityDot = rcp(VelocityDot + 0.0001f); // Add a small amount to avoid division by zero.

		// Distance to the plane from the center of the particle.
		float DistanceToPlane = dot(CollisionPlane.xyz, InPosition.xyz) - CollisionPlane.w;

		// Find out the time of intersection for both the front and back of the sphere.
		float t_back = -(DistanceToPlane + CollisionRadius) * InvVelocityDot;
		float t_front = -(DistanceToPlane - CollisionRadius) * InvVelocityDot;

		//if (t_back >= 0 && t_front <= 1 && DistanceToPlane >= 0)
		if (step(0, t_back) * step(t_front, 1) * step(0, DistanceToPlane))
		{
			// Separate velocity in to the components perpendicular and tangent to the collision plane.
			float3 PerpVelocity = dot(MidVelocity,CollisionPlane.xyz) * CollisionPlane.xyz;
			float3 TanVelocity = MidVelocity - PerpVelocity;

			// Compute the new velocity accounting for resilience and friction.
			NewVelocity = Simulation.OneMinusFriction * TanVelocity - Resilience * PerpVelocity;

			// If the particle lies approximately on the collision plane, don't jump to the point of collision.
			t_front *= step(VelocityDot,-1);

			// Integrate position taking the collision in to account.
			NewPosition = InPosition + DeltaPosition * t_front + NewVelocity * (1.0f - t_front) * DeltaSeconds;

			// Update the relative time. Usually this does nothing, but if the
			// user has elected to kill the particle upon collision this will do
			// so.
			RelativeTime += Simulation.CollisionTimeBias;
		}
		//else if (t_front > 0 && t_back < 1 && DistanceToPlane < 0)
		else if (step(0, t_front) * step(t_back, 1) * step(DistanceToPlane,0))
		{
			// The particle has collided against a backface, kill it by setting
			// relative time to a value > 1.0.
			RelativeTime = 1.1f;
		}
	}
}

#endif

void PixelMain(
	in FShaderInterpolants Interpolants,
	out float4 OutPosition : SV_Target0,
	out float4 OutVelocity : SV_Target1
	)
{
	// Initialize force to the constant acceleration.
	float3 Force = Simulation.Acceleration;

	// Sample the current position, velocity, and attributes for this particle.
	const float4 PositionSample = Texture2DSample(PositionTexture, PositionTextureSampler, Interpolants.TexCoord.xy);
	const float4 VelocitySample = Texture2DSample(VelocityTexture, VelocityTextureSampler, Interpolants.TexCoord.xy );
	const float4 InitialAttributes = Texture2DSample(AttributesTexture, AttributesTextureSampler, Interpolants.TexCoord.xy ) *
		Simulation.AttributeScale + Simulation.AttributeBias;

	// Velocity.w holds the time scale for this particle.
	float3 Velocity = VelocitySample.xyz;
	const float TimeScale = VelocitySample.w;

	// Position.w holds the relative time of the particle.
	float3 Position = PositionSample.xyz;
	float RelativeTime = PositionSample.w + DeltaSeconds * TimeScale;

	// Sample the attribute curve.
	const float2 AttributeCurveTexCoord = Simulation.AttributeCurve.xy +
		Simulation.AttributeCurve.zw * RelativeTime;
	const float4 AttributeCurve = Texture2DSample(CurveTexture, CurveTextureSampler, AttributeCurveTexCoord ) *
		Simulation.AttributeCurveScale + Simulation.AttributeCurveBias;

	// Simulation attributes.
	const float4 Attributes = InitialAttributes * AttributeCurve;
	const float DragCoefficient = Attributes.r;
	const float PerParticleVectorFieldScale = Attributes.g;
	const float Resilience = Attributes.b;
	const float OrbitRandom = Attributes.a;
	
	// Evalute vector fields.
	float3 FieldForce = 0;
	float4 FieldVelocity = 0;
	EvaluateVectorFields(FieldForce, FieldVelocity, Position.xyz, PerParticleVectorFieldScale);

	// NVCHANGE_BEGIN: JCAO - Replace vector fields with APEX turbulence velocity fields
#if WITH_APEX_TURBULENCE
	if (VectorFields.VelocityFieldCount > 0)
	{
		EvaluateVelocityFields(FieldVelocity, Position.xyz, PerParticleVectorFieldScale);
	}
#endif
	// NVCHANGE_END: JCAO - Replace vector fields with APEX turbulence velocity fields

	// Add in force from vector fields.
	Force += FieldForce;

	// NVCHANGE_BEGIN: JCAO - Support Force Type Noise
#if WITH_APEX_TURBULENCE
	float3 NoiseForce = 0;
	// Add in noise force
	EvaluateNoiseFS(NoiseForce, Position.xyz);
	Force = lerp(NoiseForce, Force, FieldVelocity.w);
#endif
	// NVCHANGE_END: JCAO - Support Force Type Noise

	// NVCHANGE_BEGIN: JCAO - Add Attractor working with GPU particles
#if WITH_APEX_TURBULENCE
	float4 AttractorVelocity = 0;
	EvaluateAttractorFS(AttractorVelocity, Position.xyz);
	Velocity.xyz = lerp(Velocity.xyz, AttractorVelocity.xyz, AttractorVelocity.w);
#endif // WITH_APEX_TURBULENCE
	// NVCHANGE_END: JCAO - Add Attractor working with GPU particles

	// Account for direct velocity.
	const float DirectVelocityAmount = FieldVelocity.w;
	Velocity.xyz = lerp(Velocity.xyz, FieldVelocity.xyz, DirectVelocityAmount);

	// Compute force due to drag.
	Force += ComputeDrag(Velocity.xyz, DragCoefficient);

	// Compute force to a point gravity source.
	Force += ComputeAttractionForce(Position.xyz);

	// Compute the acceleration to apply to the particle this frame.
	float3 Acceleration = Force * DeltaSeconds;

#if DEPTH_BUFFER_COLLISION || DISTANCE_FIELD_COLLISION
	// We need to look up render attributes for this particle to figure out how big it is.
	float4 RenderAttributeSample = Texture2DSampleLevel(RenderAttributesTexture, RenderAttributesTextureSampler, Interpolants.TexCoord.xy, 0);
	
	// Sample the misc render attributes curve.
	float2 MiscCurveTexCoord = Simulation.MiscCurve.xy + Simulation.MiscCurve.zw * RelativeTime;
	float4 MiscCurveSample = Texture2DSampleLevel(CurveTexture, CurveTextureSampler, MiscCurveTexCoord, 0 );
	float4 MiscCurve = MiscCurveSample * Simulation.MiscScale + Simulation.MiscBias;

	// Compute the size of the sprite. Note it is (0,0) if the sprite is dead.
	float2 InitialSize = abs(RenderAttributeSample.xy);
	float2 SizeScale = MiscCurve.xy;
	float2 Size = InitialSize * SizeScale * LocalToWorldScale;

	// Compute the radius with which to perform collision checks.
	float CollisionRadius = min(Size.x,Size.y) * Simulation.CollisionRadiusScale + Simulation.CollisionRadiusBias;
#endif

#if DEPTH_BUFFER_COLLISION
	
	// Compute the new position and velocity of the particle by colliding against
	// the scene's depth buffer.
	float3 NewPosition, NewVelocity;
	CollideWithDepthBuffer(
		NewPosition.xyz,
		NewVelocity.xyz,
		RelativeTime,
		Position.xyz,
		Velocity.xyz,
		Acceleration,
		CollisionRadius,
		Resilience
		);
#elif DISTANCE_FIELD_COLLISION

	float3 NewPosition, NewVelocity;

	CollideWithDistanceField(
		NewPosition.xyz,
		NewVelocity.xyz,
		RelativeTime,
		Position.xyz,
		Velocity.xyz,
		Acceleration,
		CollisionRadius,
		Resilience
		);

#else 
	// Integrate position and velocity forward.
	float3 DeltaPosition = DeltaSeconds * (Velocity.xyz + 0.5f * Acceleration);
	float3 NewPosition = Position.xyz + DeltaPosition;
	float3 NewVelocity = Velocity.xyz + Acceleration;
#endif

	
	// Apply orbit.
	const float3 OrbitVelocity = ComputeOrbitVelocity(RelativeTime, OrbitRandom);

	// Store the new position, time, and velocity for the particle.
	OutPosition.xyz = NewPosition + OrbitVelocity * DeltaSeconds + PositionOffsetAndAttractorStrength.xyz;
	OutPosition.w = RelativeTime;
	OutVelocity.xyz = NewVelocity;
	OutVelocity.w = TimeScale;
}

#endif // #if PARTICLE_SIMULATION_PIXELSHADER

/*------------------------------------------------------------------------------
	Clear particle simulation pixel shader.
------------------------------------------------------------------------------*/
#if PARTICLE_CLEAR_PIXELSHADER

void PixelMain(
	in FShaderInterpolants Interpolants,
	out float4 OutPosition : SV_Target0
	)
{
	// Relative time just needs to be >1.0f so the particle is considered dead.
	OutPosition = float4(0,0,0,2.0f);
}

#endif // #if PARTICLE_CLEAR_PIXELSHADER

