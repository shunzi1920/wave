<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="x-ua-compatible" content="IE=Edge"/>
    
    <title>NVIDIA WaveWorks 1.6. &mdash; NVIDIA WaveWorks 1.6.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/breathe.css" type="text/css" />
    <link rel="stylesheet" href="_static/application.css" type="text/css" />
    <link rel="stylesheet" href="_static/styleguide.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.6.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/bootstrap.js"></script>
    <link rel="top" title="NVIDIA WaveWorks 1.6.1 documentation" href="index.html" />
    <link rel="next" title="Release Notes" href="releasenotes.html" />
    <link rel="prev" title="NVIDIA WaveWorks" href="index.html" /> 
  </head>
  <body>
<nav class="navbar navbar-inverse navbar-default">
  <div class="row">
      <div class="navbar-brand">
             <img class="logo" src="_static/developerzone_gameworks_logo.png" alt="Logo"/>
      </div>
  </div>
</nav>
<div class="masthead">
    <div class="row">
      <ul class="breadcrumb">
        <li><a href="index.html">NVIDIA WaveWorks 1.6.1 documentation</a></li> 
      </ul>
    </div>
</div>
<div class="row">
  <div class="col-md-3 bs-sidenav">
<div class="bs-sidebar">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <div id="sidebar_toc">
  <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="">NVIDIA WaveWorks 1.6.</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#getting-started">Getting Started</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#core-simulation">Core simulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#geometry-generators">Geometry generators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#shader-integration">Shader integration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#opengl-compatibility">OpenGL compatibility</a></li>
<li class="toctree-l3"><a class="reference internal" href="#device-save-restore">Device save/restore</a></li>
<li class="toctree-l3"><a class="reference internal" href="#host-readback">Host readback</a></li>
<li class="toctree-l3"><a class="reference internal" href="#synchronization">Synchronization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#statistics">Statistics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#browse-documentation">Browse Documentation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="releasenotes.html">Release Notes</a></li>
<li class="toctree-l3"><a class="reference internal" href="changelog.html">Change Log</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">NVIDIA WaveWorks</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="releasenotes.html"
                        title="next chapter">Release Notes</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search form-inline" action="search.html" method="get">
      <div class="form-group">
      <input type="text" name="q" class="form-control" />
      <input type="submit" value="Search" class="btn btn-primary" />
      </div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
</div>
  </div>
    <div class="document col-md-8">
          <div class="body">
            
  <div class="section" id="productname-version">
<h1>NVIDIA WaveWorks 1.6.<a class="headerlink" href="#productname-version" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>NVIDIA WaveWorks enables developers to deliver a cinematic-quality ocean simulation for interactive applications. The simulation runs in the frequency domain, using a spectral wave dispersion model. An inverse FFT step then transforms to the spatial domain, ready for rendering. The NVIDIA WaveWorks simulation is initialized and controlled by a simple C API, and the results are accessed for rendering through a HLSL shader API. Parameterization is done via intuitive real-world variables, such as wind speed and direction. These parameters can be used to tune the look of the sea surface for a wide variety of conditions – from gentle ripples to a heavy storm-tossed ocean based on the Beaufort scale.</p>
<p>In addition, we also provide an energy-based surface foam simulation, which is locked to and driven by the underlying spectral simulation. The foam simulation results are also exposed through HLSL shader API, and permit full customization of the foam look, according to physical properties like surface energy and mixed-in turbulent energy. Version 1.3 also adds optional support for greatly simplified parameterization choices based on the Beaufort scale.</p>
<p>Version 1.4 adds support for running in ‘no-graphics’ mode, where the application consumes simulation results via displacement queries only. This mode is aimed initially at the MMO server use-case, and is currently supported for Windows and Linux for simulations running on both CPU and GPU. Importantly, the simulation will always produce the same result for a given time value, which means it can be synchronized between the multiple nodes of a networked application.</p>
<p>Features</p>
<ul class="simple">
<li>Controlled via a simple C API</li>
<li>Simulation results accessed via HLSL API. Lighting/shading remains under full application control</li>
<li>Flexible save/restore for D3D state across C API calls</li>
<li>Quad-tree tile-based LODing Host readback (e.g. for simulation of water-borne objects)</li>
<li>DX11 tessellation; geo-morphing for DX9/10</li>
<li>Foam simulation Beaufort presets</li>
<li>GPU acceleration for evolving spectra</li>
<li>A &#8220;no graphics&#8221; path, for clients who need only readback results (e.g. MMO servers)</li>
<li>Linux port available</li>
<li>Next-gen console ports available</li>
<li>Win/GL port available</li>
<li>Mac/GL port available</li>
</ul>
<img alt="_images/WaveWorks_ship.png" src="_images/WaveWorks_ship.png" />
</div>
<div class="section" id="getting-started">
<h2>Getting Started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h2>
<p>The sample app is a good place to start if you want to see how to integrate the library. This app is located in the &#8216;sample&#8217; directory. The library must be globally initialized using <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_InitXXXX()</span></tt> before attempting to create objects and run simulations. However not all entrypoints are subject to this rule - the following entrypoints <em>can</em> safely be called without first initialising the library (because they are get-only informational functions):</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_GetBuildString()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_DetailLevelIsSupported_XXXX()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_GetShaderInputCountXXXX()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_GetShaderInputDescXXXX()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Quadtree_GetShaderInputCountXXXX()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Quadtree_GetShaderInputDescXXXX()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_GLAttribIsShaderInput()</span></tt></li>
</ul>
<p>Note that throughout this documentation, &#8216;XXXX&#8217; is used to represent the graphics API permutations offered by the library (so D3D9/D3D10/D3D11/NoGraphics/Gnm/GL2, etc.)</p>
<div class="section" id="core-simulation">
<h3>Core simulation<a class="headerlink" href="#core-simulation" title="Permalink to this headline">¶</a></h3>
<p>An understanding of the underlying FFT-based technique is helpful when setting up a simulation (see: <a class="reference external" href="http://graphics.ucsd.edu/courses/rendering/2005/jdewall/tessendorf.pdf">http://graphics.ucsd.edu/courses/rendering/2005/jdewall/tessendorf.pdf</a> ).The library actually runs a cascade of such FFT simulations, with each successive cascade member covering a greater footprint in world space than the previous member. This cascade of simulations is used to achieve smooth LODing without repetition artifacts when rendering the water surface. The cascaded nature of the simulation should be invisible to clients of the library - the library operates as a &#8216;black box&#8217; in this repsect, allowing only for the overall properties of the simulation to be specified, and for the displacements/gradients to be accessed during rendering.The client app initializes a simulation by filling out a <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_Settings</span></tt> and a <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_Params</span></tt>, and passing them to <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_CreateXXXX()</span></tt>. The properties for a simulation can also be updated later, by calling <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_UpdateProperties()</span></tt>, but note that this can cause simulation resources to be reallocated (depending on which properties are changed; e.g., detail level). A simulation has the following parameters:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">wave_amplitude</span></tt> - global scale factor for simulated wave amplitude.</li>
<li><tt class="docutils literal"><span class="pre">wind_dir</span></tt> - the direction of the wind inducing the waves.</li>
<li><tt class="docutils literal"><span class="pre">wind_speed</span></tt> - the speed of the wind inducing the waves. If GFSDK_WaveWorks_Simulation_Settings.UseBeaufortScale is set, this is interpreted as a Beaufort scale value. Otherwise, it is interpreted as metres per second</li>
<li><tt class="docutils literal"><span class="pre">wind_dependency</span></tt> - the degree to which waves appear to move in the wind direction (vs. standing waves), in the [0,1] range</li>
<li><tt class="docutils literal"><span class="pre">choppy_scale</span></tt> - in addition to height displacements, the simulation also applies lateral displacements. This controls the non-linearity and therefore &#8216;choppiness&#8217; in the resulting wave shapes. Should normally be set in the [0,1] range.</li>
<li><tt class="docutils literal"><span class="pre">small_wave_fraction</span></tt> - the simulation spectrum is low-pass filtered to eliminate wavelengths that could end up under-sampled, this controls how much of the frequency range is considered &#8216;high frequency&#8217; (i.e. small wave).</li>
<li><tt class="docutils literal"><span class="pre">time_scale</span></tt> - the global time multiplier.</li>
<li><tt class="docutils literal"><span class="pre">foam_generation_threshold</span></tt> - the turbulent energy representing foam and bubbles spread in water starts generating on the tips of the waves if Jacobian of wave curvature gets higher than this threshold. The range is [0,1], the typical values are [0.2,0.4] range.</li>
<li><tt class="docutils literal"><span class="pre">foam_generation_amount</span></tt> - the amount of turbulent energy injected in areas defined by foam_generation_threshold parameter on each simulation step. The range is [0,1], the typical values are [0,0.1] range.</li>
<li><tt class="docutils literal"><span class="pre">foam_dissipation_speed</span></tt> - the speed of spatial dissipation of turbulent energy. The range is [0,1], the typical values are in [0.5,1] range.</li>
<li><tt class="docutils literal"><span class="pre">foam_falloff_speed</span></tt> - in addition to spatial dissipation, the turbulent energy dissolves over time. This parameter sets the speed of dissolving over time. The range is [0,1], the typical values are in [0.9,0.99] range.</li>
</ul>
<p>A simulation has the following settings:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">detail_level</span></tt> - the detail level of the simulation: this drives the resolution of the FFT, and also determines whether the simulation workload is done on the GPU or CPU (but see note below on hardware support).</li>
<li><tt class="docutils literal"><span class="pre">fft_period</span></tt> - the repeat interval of the simulation, in metres. The simulation should generate unique results within any fft_period x fft_period area.</li>
<li><tt class="docutils literal"><span class="pre">use_Beaufort_scale</span></tt> - how to interpret <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_Params::wind_speed</span></tt>. If true, interpret as a Beaufort scale quantity, and use dependent presets for all other params.</li>
<li><tt class="docutils literal"><span class="pre">readback_displacements</span></tt> - true if <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_GetDisplacements()</span></tt> should apply the simulated displacements.</li>
<li><tt class="docutils literal"><span class="pre">num_readback_FIFO_entries</span></tt> - if readback is enabled, displacement data can be kept alive in a FIFO for historical lookups. e.g. in order to implement predict/correct for a networked application</li>
<li><tt class="docutils literal"><span class="pre">aniso_level</span></tt> - this should be set to desired anisotropic filtering degree for sampling of gradient maps. This value is clamped to [1,16] range internally, and it should be be clamped further to the range supported by the GPU.</li>
<li><tt class="docutils literal"><span class="pre">CPU_simulation_threading_model</span></tt> - the threading model to use when the CPU simulation path is active. Can be set to none (meaning: simulation is performed on the calling thread, synchronously), automatic, or even an explicitly specified thread count</li>
<li><tt class="docutils literal"><span class="pre">num_GPUs</span></tt> - this should be set to the number of SLI AFR groups detected by the app via NVAPI (e.g. set to 1 for the single GPU case).</li>
<li><tt class="docutils literal"><span class="pre">use_texture_arrays</span></tt> - true if texture arrays should be used in GL (requires fewer texture units)</li>
<li><tt class="docutils literal"><span class="pre">enable_CUDA_timers</span></tt> - controls whether timer events will be used to gather stats on the CUDA simulation path. This can impact negatively on GPU/CPU parallelism, so it is recommended to enable this only when necessary</li>
</ul>
<p>A note on hardware support: not all hardware is capable of supporting all possible settings for <tt class="docutils literal"><span class="pre">detail_level</span></tt> - settings that are not supported on the current hardware will cause <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_CreateXXXX()</span></tt> to fail. This can be tested in advance of creation using <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_DetailLevelIsSupported_XXXX()</span></tt>. Once a simulation has been initialized, the application should:</p>
<ul class="simple">
<li>call <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_SetTime()</span></tt> once per simulation step to set the current time.</li>
<li>call <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_KickXXXX()</span></tt> once per simulation step to pump the simulation pipeline.</li>
<li>call <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_SetRenderStateXXXX()</span></tt> once per frame to bind the simulation outputs as shader inputs ready for rendering.</li>
</ul>
<p>If the application uses a dedicated thread for rendering, these per-frame calls should be made on that thread.</p>
<p>Note that the simulation is pipelined, therefore it may be necessary to &#8216;prime&#8217; the pipeline on the first frame after intialization by pushing multiple simulation steps via <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_KickXXXX()</span></tt>. <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_GetStagingCursor()</span></tt> will return &#8216;gfsdk_waveworks_result_OK&#8217; when enough steps have been pushed to prime the pipeline.</p>
</div>
<div class="section" id="geometry-generators">
<h3>Geometry generators<a class="headerlink" href="#geometry-generators" title="Permalink to this headline">¶</a></h3>
<p>The lib is designed to support different methods for generating geometry. A geometry-generator is expected to minimally take care of frustum culling, distance LODing, labeling of non-water regions (i.e., inland areas) and initiation of drawing. The client app can either select a &#8216;stock&#8217; geometry-generator from the lib (including any corresponding shader fragments), or it can implement its own geometry generator. A geometry-generator interfaces with the lib at the shader-fragment level. Specifically:</p>
<ul class="simple">
<li>it should define a vertex input struct, <tt class="docutils literal"><span class="pre">GFSDK_WAVEWORKS_VERTEX_INPUT</span></tt>.</li>
<li>it should define <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_GetUndisplacedVertexWorldPosition()</span></tt>.</li>
<li>it should issue draw calls as necessary, with a stream of <tt class="docutils literal"><span class="pre">GFSDK_WAVEWORKS_VERTEX_INPUT</span></tt>&#8216;s bound to the vertex shader.</li>
</ul>
<p><strong>Quad-tree generator</strong></p>
<p>This geometry-generator uses a hierarchical quad-tree of square patches. All patches have the same number of triangles (apart from edge fixups), so the quad-tree generator uses smaller patches nearer the camera, in order to achieve greater overall mesh density where it is most needed. The D3D11 path uses hardware tessellation to smoothly vary the triangle rate of mesh, the D3D9 and D3D10 paths use geomorphing. The client app initializes a quad-tree generator by filling out a <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Quadtree_Params</span></tt> and passing it to <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Quadtree_CreateXXXX()</span></tt>. The parameters can also be updated later on by calling <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Quadtree_UpdateParams()</span></tt>, although again, this is best avoided for performance reasons. A quad-tree generator has the following parameters:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">mesh_dim</span></tt>  - the number of triangles along the side of a single patch.</li>
<li><tt class="docutils literal"><span class="pre">min_patch_length</span></tt>  - the size of the smallest permissible leaf patch, in world space.</li>
<li><tt class="docutils literal"><span class="pre">patch_origin</span></tt>  - the coordinates of the min corner of patch (0,0) at some LOD (used only with <tt class="docutils literal"><span class="pre">AllocPatch/FreePatch</span></tt>).</li>
<li><tt class="docutils literal"><span class="pre">auto_root_lod</span></tt>  - the LOD of the root patch (only when <tt class="docutils literal"><span class="pre">AllocPatch/FreePatch</span></tt> are <em>not</em> used).</li>
<li><tt class="docutils literal"><span class="pre">upper_grid_coverage</span></tt> - the maximum number of pixels a patch can cover (used to choose patch LODs).</li>
<li><tt class="docutils literal"><span class="pre">sea_level</span></tt> - the vertical offset required to place the surface at sea level.</li>
<li><tt class="docutils literal"><span class="pre">use_tessellation</span></tt> - whether to use tessellation for DX11/GL4.</li>
<li><tt class="docutils literal"><span class="pre">tessellation_lod</span></tt> - for DX11, the adaptive tessellation density.</li>
<li><tt class="docutils literal"><span class="pre">geomorphing_degree</span></tt> - for DX9/10, the degree of geomorphing to apply, in the [0,1] range. High levels of geomorphing require greater triangle density in the underlying mesh.</li>
</ul>
<p>The quad-tree generator can be used in two modes: automatic and explicit.</p>
<p>In automatic mode, <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Quadtree_AllocPatch</span></tt> and <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Quadtree_FreePatch</span></tt> are never called. Therefore, the water surface is assumed to be infinite in extent, and traversal of the quad-tree begins at the LOD level specified by <em>auto_root_lod</em> .</p>
<p>In explicit mode, the client app makes calls to <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Quadtree_AllocPatch</span></tt> and <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Quadtree_FreePatch</span></tt> to load/unload patches and marks them as present or not-present (using the &#8216;enabled&#8217; parameter). Traversal of the quad-tree begins at the highest-LOD allocated patches.</p>
<p>To traverse the quad-tree and draw its visible patches, call <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Quadtree_DrawXXXX()</span></tt>.</p>
<p>The quad-tree generator performs frustum culling against undisplaced tile bounds which can lead to artifacts when simulation displacements are added during shading. For this reason, a quad-tree culling margin can be specified using <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Quadtree_SetFrustumCullMargin()</span></tt>. An appropriate culling margin value can be obtained from a simulation using <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_GetConservativeMaxDisplacementEstimate()</span></tt>, but clients should add a further margin for any client-generated displacements applied during shading (e.g. boat wakes, explosion craters).</p>
</div>
<div class="section" id="shader-integration">
<h3>Shader integration<a class="headerlink" href="#shader-integration" title="Permalink to this headline">¶</a></h3>
<p>For Direct3D 9 and Direct3D 10 apps, the shader-level integration works as follows:</p>
<ol class="arabic simple">
<li>The application calls <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_GetDisplacedVertex()</span></tt> in its vertex shader. This returns a <tt class="docutils literal"><span class="pre">GFSDK_WAVEWORKS_VERTEX_OUTPUT</span></tt>, which contains the world position and displacement generated by the simulation for the displaced vertex, and also an &#8216;interp&#8217; member, which the app should pass to its pixel shader.</li>
<li>The application calls <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_GetSurfaceAttributes()</span></tt> in its pixel shader, passing in the &#8216;interp&#8217; data generated in the vertex shader. This returns a <tt class="docutils literal"><span class="pre">GFSDK_WAVEWORKS_SURFACE_ATTRIBUTES</span></tt>, which contains the water surface normal generated by the simulation.</li>
</ol>
<p>For Direct3D 11 apps, the shader-level integration is slightly different due to the use of tessellation:</p>
<ol class="arabic simple">
<li>The application calls <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_GetUndisplacedVertexWorldPosition()</span></tt> in its vertex shader. This returns a float4 world position, which should be passed on to the hull shader stage.</li>
<li>In the hull shader, the application calls <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_GetEdgeTessellationFactor()</span></tt> to calculate the tessellation factor for a particular edge, passing in the world positions of the ends of the edge.</li>
<li>The application calls <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_GetDisplacedVertexAfterTessellation()</span></tt> in its domain shader. This returns a GFSDK_WAVEWORKS_VERTEX_OUTPUT, which contains the world position and displacement generated by the simulation for the displaced vertex, and also an &#8216;interp&#8217; member which the app should pass to its pixel shader.</li>
</ol>
<p><strong>GFSDK_WAVEWORKS_VERTEX_OUTPUT structure</strong></p>
<p><tt class="docutils literal"><span class="pre">GFSDK_WAVEWORKS_VERTEX_OUTPUT</span></tt> is returned by <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_GetDisplacedVertex()</span></tt>, which is to be called in vertex shader in case of Direct3D 9 or Direct3D 10 integration, or <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_GetDisplacedVertexAfterTessellation()</span></tt> is called in domain shader in case of Direct3D 11 integration. It contains the following members:</p>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">GFSDK_WAVEWORKS_INTERPOLATED_VERTEX_OUTPUT</span> <span class="pre">interp</span></tt> - this structure holds internal parameters that need to be passed to pixel shader and <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_GetSurfaceAttributes()</span></tt> function.</li>
<li><tt class="docutils literal"><span class="pre">float3</span> <span class="pre">pos_world</span></tt> - worldspace position of displaced water vertex. Note that the x and y axes lie on the water plane, and the z axis is oriented towards the sky.</li>
<li><tt class="docutils literal"><span class="pre">float3</span> <span class="pre">pos_world_undisplaced</span></tt> - the original position of water vertex before the displacement is applied. This parameter can be used if one needs to generate texture coords based on non-displaced water surface.</li>
<li><tt class="docutils literal"><span class="pre">float3</span> <span class="pre">world_displacement</span></tt> - the actual displacement that was applied to the water vertex. This parameter can be used for implementing complex water surface shading.</li>
</ol>
<p><strong>GFSDK_WAVEWORKS_SURFACE_ATTRIBUTES structure</strong></p>
<p>GFSDK_WAVEWORKS_SURFACE_ATTRIBUTES structure is returned by <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_GetSurfaceAttributes()</span></tt> called in pixel shader. It contains the following members:</p>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">float3</span> <span class="pre">normal</span></tt> - the per-pixel water surface normal. It can be used to calculate Fresnel, reflection, refraction, etc.</li>
<li><tt class="docutils literal"><span class="pre">float3</span> <span class="pre">eye_dir</span></tt> - normalized water surface pixel to camera position vector in worldspace coordinates. It can be used to calculate specular reflection, Fresnel, etc.</li>
<li><tt class="docutils literal"><span class="pre">float</span> <span class="pre">foam_surface_folding</span></tt> - this value provides the resulting amount of &#8220;squeezing&#8221; or &#8220;stretching&#8221; of the water surface, the range of values are [-1,1]. It is negative in areas where the water surface is &#8220;stretched;&#8221; for instance, in valleys between the waves, and positive on tips of the waves. It is useful for rendering water surface foam: the foam is expected to be denser in &#8220;squeezed&#8221; areas and thinner in &#8220;stretched&#8221; areas.</li>
<li><tt class="docutils literal"><span class="pre">float</span> <span class="pre">foam_turbulent_energy</span></tt> - this value provides the result of turbulent energy simulation, the range is [0,+inf], and the actual value highly depends on foam simulation parameters. This value is used to render surface foam and bubbles spread in water. It is zero in areas where turbulent energy is absent, and it is positive in areas where turbulent energy is present. The higher the value, the more turbulent energy exists in the area, and the denser foam can be applied to the water surface.</li>
<li><tt class="docutils literal"><span class="pre">float</span> <span class="pre">foam_wave_hats</span></tt> - this value marks the areas where turbulent energy is generated: the very tips of the waves that are about to break. The range is [0,+inf], and the actual value depends on foam simulation parameters. This value is used to render foamy wave tips: an additional foam texture can be modulated by this value.</li>
</ol>
<p><strong>Register assignments</strong></p>
<p>The shader fragments use various constants and resources which need to be assigned to registers. No two applications handle their register assignments in the same way, so the library allow applications to manage assignments by defining pre-processor macros. The sample app shows how to define the macros so that registers are assigned via name-based lookup (for use with the <tt class="docutils literal"><span class="pre">D3DXEffect</span></tt> framework) - see <tt class="docutils literal"><span class="pre">ocean_surface.fx</span></tt>. Alternatively, it is possible to define the macros so that registers are assigned to pre-determined contiguous ranges.</p>
<p>The application communicates register assignments to the library via the <tt class="docutils literal"><span class="pre">pShaderInputRegisterMappings</span></tt> parameter (see <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_SetRenderStateXXXX()</span></tt> and <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Quadtree_DrawXXXX()</span></tt>). This should point to an array of UINTs of the size specified by <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_XXX_GetShaderInputCountXXXX()</span></tt> - each entry in the array represents a register mapping. A description of <em>what</em> is being mapped by an entry can be obtained by calling <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_XXX_GetShaderInputDescXXXX()</span></tt> - this returns a <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_ShaderInput_Desc</span></tt>, which the application can use to determine which register applies to which entry. The sample apps use the <em>Type</em> and <em>Name</em>  information in <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_ShaderInput_Desc</span></tt> to fetch register assignments from <tt class="docutils literal"><span class="pre">D3DXEffect</span></tt>. Alternatively, an application might use <em>RegisterOffset</em>  in cases where registers are assigned to pre-determined contiguous ranges.</p>
</div>
<div class="section" id="opengl-compatibility">
<h3>OpenGL compatibility<a class="headerlink" href="#opengl-compatibility" title="Permalink to this headline">¶</a></h3>
<p>WaveWorks targets GL2, meaning it will only ever call GL entrypoints that are part of the GL2 core spec.</p>
<p>However, it is perfectly possible to use WaveWorks with later-version GL contexts, provided you fully understand the implications. In particular, watch out for:</p>
<ol class="arabic simple">
<li>VAOs - WaveWorks will not create or bind/unbind VAOs. If an app leaves a VAO bound prior to calling a GL-specific WaveWorks entrypoint, it is likely that the state of the VAO will be disrupted by WaveWorks. The recommended usage pattern here is for the app to create a VAO specifically for WaveWorks, and bind it prior to calling any WaveWorks entrypoint with &#8216;GL&#8217; in the name. The VAO will act as a sandpit and prevent vertex-related state-changes leaking out of WaveWorks and affecting the rest of the app</li>
<li>Samplers - WaveWorks will not create or bind/unbind samplers. If an app leaves a sampler bound prior to calling a GL-specific WaveWorks entrypoint, it is likely that the sampler state will override the texture object state set by WaveWorks, leading to undefined results. The recommended usage pattern here is to unbind all samplers prior to calling any WaveWorks entrypoint with &#8216;GL&#8217; in the name.</li>
</ol>
<p>For GL rendering, it is necessary to reserve a handful of texture units for WaveWorks&#8217; exclusive use. These reserved texture units are specified to WaveWorks by filling out the
GFSDK_WaveWorks_Simulation_GL_Pool data structure. The number of units required can be queried by calling GFSDK_WaveWorks_Simulation_GetTextureUnitCountGL2(), and the answer will
depend on whether the path that uses GL texture arrays has been specified. This option causes WaveWorks to use a combined texture array for shader input, which has the benefit of
reducing the number of texture units required at the expense of some additional internal copying of simulation data.</p>
</div>
<div class="section" id="device-save-restore">
<h3>Device save/restore<a class="headerlink" href="#device-save-restore" title="Permalink to this headline">¶</a></h3>
<p>The library makes extensive changes to graphics device state, and this can cause problems with applications that have their own device state management layer, or which make assumptions about device state being preserved at certain times. For this reason, the library provides an optional facility to selectively save and restore device state across library calls, or (and this is important for efficiency) groups of calls. To use device state save/restore:</p>
<ol class="arabic simple">
<li>On initialization, call <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Savestate_CreateXXX()</span></tt> to create a save-state object - the creation flags are used to determine what state the object will manage.</li>
<li>Pass the save-state object handle to functions that accept an hSavestate handle.</li>
<li>Call <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Savestate_Restore()</span></tt> to restore the device state that was overwritten by the last batch of library calls.</li>
</ol>
<p>Note that save/restore is offered only for graphics APIs where the device state can be queried efficiently - for example, it is not offered for OpenGL or GNM.</p>
<p>For OpenGL, clients of the library may implement save/restore by hooking their own wrapper functions into the table of GL entrypoint bindings (GFSDK_WAVEWORKS_GLFunctions) which is passed to the library on initialization. Also, be aware that the majority of OpenGL state-disruption issues can be solved with the following application changes:</p>
<ol class="arabic simple">
<li>if the application uses VAOs, create a dedicated VAO just for WaveWorks and bind it prior to calls to WaveWorks GL functions (see &#8216;OpenGL compatibility&#8217;)</li>
<li>restore glViewport() as necessary after calls to WaveWorks entrypoints with &#8216;GL&#8217; in the name</li>
<li>restore the state of GL_DEPTH_TEST as necessary after calls to WaveWorks with &#8216;GL&#8217; in the name</li>
<li>if the application uses samplers, ensure all samplers are unbound prior to calls to WaveWorks GL functions (see &#8216;OpenGL compatibility&#8217;)</li>
</ol>
</div>
<div class="section" id="host-readback">
<h3>Host readback<a class="headerlink" href="#host-readback" title="Permalink to this headline">¶</a></h3>
<p>Some applications will need access to the displacements generated by the simulation (for example, so that water-borne objects can be made to bob accurately). Applications can use <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_GetDisplacements()</span></tt> for this - the application provides an array of world x-y coordinates, for which displacements are to be retrieved, and the function fills out a corresponding array with the displacement data. Note that this call will only provide non-zero data if the <em>readback_displacements</em> flag is set.</p>
<p><strong>Readback FIFO</strong></p>
<p>It is possible to archive a limited history of readback results in a FIFO maintained by the WaveWorks simulation. The number of entries available for this is determined by the <tt class="docutils literal"><span class="pre">num_readback_FIFO_entries</span></tt> setting.
Readback results are pushed efficiently into the FIFO by calling <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_ArchiveDisplacements()</span></tt> (but note that this could evict older entries if the FIFO is full!).
FIFO results can then be accessed using <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_GetArchivedDisplacements()</span></tt>. This is identical to the <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_GetDisplacements()</span></tt>, save for the additional <tt class="docutils literal"><span class="pre">coord</span></tt> argument
which is used to specify which FIFO entry (or entries - interpolation is allowed) to read from.</p>
<p>Calculation of first (velocity) or second (acceleration) derivatives is a possibe application of readback FIFO.</p>
<p><strong>Ray-casting</strong></p>
<p>Applications may need to perform ray-cast tests against the simulated ocean surface e.g. to detect when the path of a bullet intersects a wave.</p>
<p>The <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_GetDisplacements()</span></tt> entrypoint cannot be used <em>directly</em> to perform ray-casting queries, since the inputs to the entrypoint are 2D parameterized world-space coordinates, not true 3D rays.</p>
<p>However, it is possible to implement ray-casting by making <em>indirect</em> use of <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_GetDisplacements()</span></tt>. The D3D11 sample app includes illustrative ray-casting code along these lines - see OceanSurface::intersectRayWithOcean().</p>
</div>
<div class="section" id="synchronization">
<h3>Synchronization<a class="headerlink" href="#synchronization" title="Permalink to this headline">¶</a></h3>
<p>Conceptually, the WaveWorks pipeline consists of two main sections:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">Staging</span></tt> - this is the top part of the pipeline which does all of the CPU-side work to prepare for rendering, <em>including</em> scheduling any GPU simulation work and any subsequent graphics interop to make results available for rendering.</li>
<li><tt class="docutils literal"><span class="pre">Readback</span></tt> - this is the bottom part of the pipeline which occurs after simulation work is complete, and which (if necessary) transfers results back to the CPU for use with physics or other application logic.</li>
</ul>
<p>WaveWorks can be driven using a number of different synchronization patterns.</p>
<ol class="arabic simple">
<li>Fully synchronized - simulation work is submitted via <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_KickXXXX()</span></tt>, the caller then uses <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_GetStagingCursor()</span></tt> and <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_AdvanceStagingCursorXXXX()</span></tt> to pump the pipeline until the results of the kick are staged for rendering.</li>
<li>Fully asynchronous - simulation work is submitted via <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_KickXXXX()</span></tt> (with multiple calls on the first frame to fill the pipeline) and staged for rendering as and when results become available.</li>
<li>Opportunistic - simulation work is submitted via <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_KickXXXX()</span></tt>, the caller then performs other useful work whilst occasionally polling for results with a non-blocking call to <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_AdvanceStagingCursorXXXX()</span></tt>.</li>
</ol>
<p>Maximum performance is achieved with a fully asynchronous pattern, and in practice it is actually very rare for an application to <em>require</em> anything
other than a fully asynchronous usage pattern. Any application where the time delta is broadly predictable one or two updates in advance
can usually be pipelined for fully asynchronous operation, and only applications with unpredictable or uncorrelated time deltas will <em>require</em>
a fully synchronous usage pattern.</p>
</div>
<div class="section" id="statistics">
<h3>Statistics<a class="headerlink" href="#statistics" title="Permalink to this headline">¶</a></h3>
<p><strong>Simulation stats</strong></p>
<p>These can be retrieved via <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Simulation_GetStats()</span></tt>. The following statistics are available:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">CPU_main_thread_wait_time</span></tt> - CPU time spent by main app thread waiting for CPU FFT simulation results.</li>
<li><tt class="docutils literal"><span class="pre">CPU_threads_start_to_finish_time</span></tt> - CPU wallclock time spent on CPU FFT simulation: time between 1st thread starts work and last thread finishes simulation work.</li>
<li><tt class="docutils literal"><span class="pre">CPU_threads_total_time</span></tt> - CPU time spent on CPU FFT simulation: sum time spent in threads that perform simulation work.</li>
<li><tt class="docutils literal"><span class="pre">GPU_simulation_time</span></tt> - GPU time spent on GPU simulation.</li>
<li><tt class="docutils literal"><span class="pre">GPU_FFT_simulation_time</span></tt> - GPU simulation time spent on FFT.</li>
<li><tt class="docutils literal"><span class="pre">GPU_gfx_time</span></tt> - GPU time spent on non-simulation; e.g., updating gradient maps.</li>
<li><tt class="docutils literal"><span class="pre">GPU_update_time</span></tt> - Total GPU time spent on UpdateTickXXXX() workloads.</li>
</ul>
<p>&#8220;<strong>Quad-tree stats</strong>&#8220;</p>
<p>These can be retrieved via <tt class="docutils literal"><span class="pre">GFSDK_WaveWorks_Quadtree_GetStats()</span></tt>. The following statistics are available:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">num_patches_drawn</span></tt> - useful for checking correct operation of frustum culling, LODing, and patch alloc/free.</li>
<li><tt class="docutils literal"><span class="pre">CPU_quadtree_update_time</span></tt> - the CPU time spent frustum culling, LODing, and patch alloc/free.</li>
</ul>
</div>
</div>
<div class="section" id="browse-documentation">
<h2>Browse Documentation<a class="headerlink" href="#browse-documentation" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="releasenotes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Change Log</a></li>
</ul>
</div>
</div>
</div>


          </div>
      <div class="clearer"></div>
    </div>
    <div class="col-md-1"></div>
</div>
<div class="masthead">
    <div class="row">
      <ul class="breadcrumb">
        <li><a href="index.html">NVIDIA WaveWorks 1.6.1 documentation</a></li> 
      </ul>
    </div>
</div>
<footer>
    <div class="footer-boilerplate">
        <div class="row">
            <div class="boilerplate">
                Copyright &copy; 2014, NVIDIA Corporation &nbsp; | &nbsp; <a href="http://www.nvidia.com/object/about-nvidia.html" onclick="s_objectID=&quot;http://www.nvidia.com/object/about-nvidia.html_1&quot;;return this.s_oc?this.s_oc(e):true">About NVIDIA </a>&nbsp; | &nbsp; <a href="http://www.nvidia.com/object/legal_info.html" onclick="s_objectID=&quot;http://www.nvidia.com/object/legal_info.html_1&quot;;return this.s_oc?this.s_oc(e):true">Legal Information </a>&nbsp; | &nbsp; <a href="http://www.nvidia.com/object/privacy_policy.html" onclick="s_objectID=&quot;http://www.nvidia.com/object/privacy_policy.html_1&quot;;return this.s_oc?this.s_oc(e):true">Privacy Policy </a>
            </div>
        </div>
    </div>
</div>
</footer>
<script>
$("#sidebar_toc ul li").each(function() {
    var handleSpan = $("<span></span>")
        .addClass("toc_handle").prependTo(this);

    if($(this).has("ul li").size() > 0) {
        handleSpan.addClass("toc_expanded").click(function() {
            $(this).toggleClass("toc_expanded toc_collapsed")
                .siblings("ul").toggle();
        });
        if(!($(this).hasClass('current'))) {
            handleSpan.click()
        }
    }
});
</script>
  </body>
</html>